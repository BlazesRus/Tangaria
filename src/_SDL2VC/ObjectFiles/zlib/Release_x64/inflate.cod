; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30142.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+108
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN9
	DD	imagerel $LN9+62
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN17+49
	DD	imagerel $LN17+91
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN17+91
	DD	imagerel $LN17+149
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateCopy DD imagerel $LN17+149
	DD	imagerel $LN17+172
	DD	imagerel $chain$4$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN17+172
	DD	imagerel $LN17+410
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflateCopy DD imagerel $LN17+410
	DD	imagerel $LN17+423
	DD	imagerel $chain$7$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN22
	DD	imagerel $LN22+34
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN22+34
	DD	imagerel $LN22+70
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN22+70
	DD	imagerel $LN22+237
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateSync DD imagerel $LN22+237
	DD	imagerel $LN22+300
	DD	imagerel $chain$5$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateSync DD imagerel $LN22+300
	DD	imagerel $LN22+322
	DD	imagerel $chain$6$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+101
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+172
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+272
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN8
	DD	imagerel $LN8+96
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN12
	DD	imagerel $LN12+147
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+145
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN1002
	DD	imagerel $LN1002+6136
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN14+67
	DD	imagerel $LN14+173
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN14+173
	DD	imagerel $LN14+225
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN14+225
	DD	imagerel $LN14+241
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 0a1801H
	DD	0123418H
	DD	0f0149218H
	DD	0d010e012H
	DD	0700cc00eH
	DD	0500a600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 0a6801H
	DD	07e468H
	DD	067460H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 062e01H
	DD	06342eH
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateSync DD 021H
	DD	imagerel $LN22+70
	DD	imagerel $LN22+237
	DD	imagerel $chain$4$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateSync DD 020521H
	DD	0a5405H
	DD	imagerel $LN22+70
	DD	imagerel $LN22+237
	DD	imagerel $chain$4$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 060a21H
	DD	04740aH
	DD	083405H
	DD	056400H
	DD	imagerel $LN22
	DD	imagerel $LN22+34
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	056405H
	DD	imagerel $LN22
	DD	imagerel $LN22+34
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 020601H
	DD	0e0025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflateCopy DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 080021H
	DD	04f400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateCopy DD 021H
	DD	imagerel $LN17+49
	DD	imagerel $LN17+91
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 020521H
	DD	04f405H
	DD	imagerel $LN17+49
	DD	imagerel $LN17+91
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 061421H
	DD	0a6414H
	DD	09540aH
	DD	083405H
	DD	imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 48
inflateReset PROC					; COMDAT

; 145  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 146  :     struct inflate_state FAR *state;
; 147  : 
; 148  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateRes
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 154  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateRes:

; 149  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 150  :     state->wsize = 0;

  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 50 34	 mov	 QWORD PTR [rax+52], rdx

; 151  :     state->whave = 0;
; 152  :     state->wnext = 0;

  00021	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 154  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 153  :     return inflateResetKeep(strm);

  00028	e9 00 00 00 00	 jmp	 inflateResetKeep
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 199  : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 200  :     int ret;
; 201  :     struct inflate_state FAR *state;
; 202  : 
; 203  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 c9 00 00
	00		 je	 $LN3@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 bf 00 00
	00		 jne	 $LN3@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 b5 00 00
	00		 jne	 $LN3@inflateIni

; 204  :         stream_size != (int)(sizeof(z_stream)))
; 205  :         return Z_VERSION_ERROR;
; 206  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN4@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 236  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN4@inflateIni:

; 207  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 208  :     if (strm->zalloc == (alloc_func)0) {

  0003f	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00043	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00048	33 ed		 xor	 ebp, ebp
  0004a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004f	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00053	48 85 c0	 test	 rax, rax
  00056	75 13		 jne	 SHORT $LN10@inflateIni

; 209  : #ifdef Z_SOLO
; 210  :         return Z_STREAM_ERROR;
; 211  : #else
; 212  :         strm->zalloc = zcalloc;

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 213  :         strm->opaque = (voidpf)0;

  0005f	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00063	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00067	8b cd		 mov	 ecx, ebp
  00069	eb 04		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  0006b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN5@inflateIni:

; 214  : #endif
; 215  :     }
; 216  :     if (strm->zfree == (free_func)0)

  0006f	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00073	75 0b		 jne	 SHORT $LN6@inflateIni

; 217  : #ifdef Z_SOLO
; 218  :         return Z_STREAM_ERROR;
; 219  : #else
; 220  :         strm->zfree = zcfree;

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0007c	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN6@inflateIni:

; 221  : #endif
; 222  :     state = (struct inflate_state FAR *)

  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0008b	ff d0		 call	 rax
  0008d	48 8b f8	 mov	 rdi, rax

; 223  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 224  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00090	48 85 c0	 test	 rax, rax
  00093	75 18		 jne	 SHORT $LN7@inflateIni
  00095	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN12@inflateIni:
  00098	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 236  : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5e		 pop	 rsi
  000ac	c3		 ret	 0
$LN7@inflateIni:

; 225  :     Tracev((stderr, "inflate: allocated\n"));
; 226  :     strm->state = (struct internal_state FAR *)state;

  000ad	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 227  :     state->strm = strm;
; 228  :     state->window = Z_NULL;
; 229  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 230  :     ret = inflateReset2(strm, windowBits);

  000b1	8b d6		 mov	 edx, esi
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	48 89 18	 mov	 QWORD PTR [rax], rbx
  000b9	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp
  000bd	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H
  000c4	e8 00 00 00 00	 call	 inflateReset2
  000c9	8b f0		 mov	 esi, eax

; 231  :     if (ret != Z_OK) {

  000cb	85 c0		 test	 eax, eax
  000cd	74 0e		 je	 SHORT $LN8@inflateIni

; 232  :         ZFREE(strm, state);

  000cf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000d3	48 8b d7	 mov	 rdx, rdi
  000d6	ff 53 38	 call	 QWORD PTR [rbx+56]

; 233  :         strm->state = Z_NULL;

  000d9	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN8@inflateIni:

; 234  :     }
; 235  :     return ret;

  000dd	8b c6		 mov	 eax, esi
  000df	eb b7		 jmp	 SHORT $LN12@inflateIni
$LN3@inflateIni:

; 236  : }

  000e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e6	b8 fa ff ff ff	 mov	 eax, -6
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5e		 pop	 rsi
  000f0	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
left$1$ = 48
hbuf$ = 52
last$ = 56
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 144
flush$ = 152
out$1$ = 160
ret$1$ = 168
inflate	PROC						; COMDAT

; 624  : {

$LN1002:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	44 8b f2	 mov	 r14d, edx
  0001b	4c 8b e1	 mov	 r12, rcx

; 625  :     struct inflate_state FAR *state;
; 626  :     z_const unsigned char FAR *next;    /* next input */
; 627  :     unsigned char FAR *put;     /* next output */
; 628  :     unsigned have, left;        /* available input and output */
; 629  :     unsigned long hold;         /* bit buffer */
; 630  :     unsigned bits;              /* bits in bit buffer */
; 631  :     unsigned in, out;           /* save starting available input and output */
; 632  :     unsigned copy;              /* number of stored or match bytes to copy */
; 633  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 634  :     code here;                  /* current decoding table entry */
; 635  :     code last;                  /* parent table entry */
; 636  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 637  :     int ret;                    /* return code */
; 638  : #ifdef GUNZIP
; 639  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 640  : #endif
; 641  :     static const unsigned short order[19] = /* permutation of code lengths */
; 642  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 643  : 
; 644  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  0001e	e8 00 00 00 00	 call	 inflateStateCheck
  00023	85 c0		 test	 eax, eax
  00025	0f 85 2e 17 00
	00		 jne	 $LN333@inflate
  0002b	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0002f	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  00034	4d 85 c9	 test	 r9, r9
  00037	0f 84 1c 17 00
	00		 je	 $LN333@inflate
  0003d	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00040	48 85 f6	 test	 rsi, rsi
  00043	75 09		 jne	 SHORT $LN750@inflate
  00045	39 71 08	 cmp	 DWORD PTR [rcx+8], esi
  00048	0f 85 0b 17 00
	00		 jne	 $LN333@inflate
$LN750@inflate:

; 647  : 
; 648  :     state = (struct inflate_state FAR *)strm->state;

  0004e	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 649  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00052	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  00056	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  0005c	75 19		 jne	 SHORT $LN4@inflate
  0005e	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H
  00066	ba 40 3f 00 00	 mov	 edx, 16192		; 00003f40H
  0006b	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0006f	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00072	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
$LN4@inflate:

; 650  :     LOAD();

  00077	44 8b 51 18	 mov	 r10d, DWORD PTR [rcx+24]

; 651  :     in = have;
; 652  :     out = left;
; 653  :     ret = Z_OK;
; 654  :     for (;;)
; 655  :         switch (state->mode) {

  0007b	8d 82 cc c0 ff
	ff		 lea	 eax, DWORD PTR [rdx-16180]
  00081	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00084	45 33 ff	 xor	 r15d, r15d
  00087	41 8b 6d 48	 mov	 ebp, DWORD PTR [r13+72]
  0008b	45 8b c2	 mov	 r8d, r10d
  0008e	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  00092	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  00097	89 7c 24 3c	 mov	 DWORD PTR in$1$[rsp], edi
  0009b	44 89 94 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r10d
  000a3	44 89 bc 24 a8
	00 00 00	 mov	 DWORD PTR ret$1$[rsp], r15d
  000ab	83 f8 1f	 cmp	 eax, 31
  000ae	0f 87 a5 16 00
	00		 ja	 $LN333@inflate
$LN999@inflate:
  000b4	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  000bb	48 98		 cdqe
  000bd	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN845@inflate[r11+rax*4]
  000c5	49 03 cb	 add	 rcx, r11
  000c8	ff e1		 jmp	 rcx
$LN335@inflate:

; 656  :         case HEAD:
; 657  :             if (state->wrap == 0) {

  000ca	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  000ce	85 d2		 test	 edx, edx
  000d0	75 0d		 jne	 SHORT $LN12@inflate

; 658  :                 state->mode = TYPEDO;

  000d2	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H

; 659  :                 break;

  000da	e9 8f 06 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 660  :             }
; 661  :             NEEDBITS(16);

  000df	83 fb 10	 cmp	 ebx, 16
  000e2	73 1e		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000e4	85 ff		 test	 edi, edi
  000e6	0f 84 01 08 00
	00		 je	 $LN963@inflate
  000ec	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000ef	8b cb		 mov	 ecx, ebx
  000f1	d3 e0		 shl	 eax, cl
  000f3	ff cf		 dec	 edi
  000f5	03 e8		 add	 ebp, eax
  000f7	48 ff c6	 inc	 rsi
  000fa	83 c3 08	 add	 ebx, 8
  000fd	83 fb 10	 cmp	 ebx, 16
  00100	72 e2		 jb	 SHORT $LL13@inflate
$LN10@inflate:

; 662  : #ifdef GUNZIP
; 663  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00102	f6 c2 02	 test	 dl, 2
  00105	74 57		 je	 SHORT $LN338@inflate
  00107	81 fd 1f 8b 00
	00		 cmp	 ebp, 35615		; 00008b1fH
  0010d	75 4f		 jne	 SHORT $LN338@inflate

; 664  :                 if (state->wbits == 0)

  0010f	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  00114	75 08		 jne	 SHORT $LN339@inflate

; 665  :                     state->wbits = 15;

  00116	41 c7 45 30 0f
	00 00 00	 mov	 DWORD PTR [r13+48], 15
$LN339@inflate:

; 666  :                 state->check = crc32(0L, Z_NULL, 0);

  0011e	45 33 c0	 xor	 r8d, r8d
  00121	33 d2		 xor	 edx, edx
  00123	33 c9		 xor	 ecx, ecx
  00125	e8 00 00 00 00	 call	 crc32

; 667  :                 CRC2(state->check, hold);

  0012a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00130	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00134	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00139	66 c7 44 24 34
	1f 8b		 mov	 WORD PTR hbuf$[rsp], 35615 ; 00008b1fH
  00140	8b c8		 mov	 ecx, eax
  00142	e8 00 00 00 00	 call	 crc32
  00147	41 89 45 20	 mov	 DWORD PTR [r13+32], eax

; 668  :                 INITBITS();

  0014b	41 8b ef	 mov	 ebp, r15d
  0014e	41 8b df	 mov	 ebx, r15d

; 669  :                 state->mode = FLAGS;

  00151	41 c7 45 08 35
	3f 00 00	 mov	 DWORD PTR [r13+8], 16181 ; 00003f35H

; 670  :                 break;

  00159	e9 06 06 00 00	 jmp	 $LN930@inflate
$LN338@inflate:

; 671  :             }
; 672  :             if (state->head != Z_NULL)

  0015e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00162	48 85 c0	 test	 rax, rax
  00165	74 0b		 je	 SHORT $LN340@inflate

; 673  :                 state->head->done = -1;

  00167	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  0016e	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
$LN340@inflate:

; 674  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00172	f6 c2 01	 test	 dl, 1
  00175	0f 84 cb 00 00
	00		 je	 $LN342@inflate
  0017b	40 0f b6 cd	 movzx	 ecx, bpl
  0017f	8b c5		 mov	 eax, ebp
  00181	c1 e8 08	 shr	 eax, 8
  00184	c1 e1 08	 shl	 ecx, 8
  00187	03 c8		 add	 ecx, eax
  00189	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  0018e	f7 e1		 mul	 ecx
  00190	8b c1		 mov	 eax, ecx
  00192	2b c2		 sub	 eax, edx
  00194	d1 e8		 shr	 eax, 1
  00196	03 c2		 add	 eax, edx
  00198	c1 e8 04	 shr	 eax, 4
  0019b	6b c0 1f	 imul	 eax, eax, 31
  0019e	3b c8		 cmp	 ecx, eax
  001a0	0f 85 a0 00 00
	00		 jne	 $LN342@inflate

; 682  :             }
; 683  :             if (BITS(4) != Z_DEFLATED) {

  001a6	8b c5		 mov	 eax, ebp
  001a8	24 0f		 and	 al, 15
  001aa	3c 08		 cmp	 al, 8
  001ac	74 19		 je	 SHORT $LN26@inflate

; 684  :                 strm->msg = (char *)"unknown compression method";

  001ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  001b5	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 685  :                 state->mode = BAD;

  001ba	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 686  :                 break;

  001c2	e9 a7 05 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 687  :             }
; 688  :             DROPBITS(4);
; 689  :             len = BITS(4) + 8;
; 690  :             if (state->wbits == 0)

  001c7	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  001cb	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001ce	c1 ed 04	 shr	 ebp, 4
  001d1	8b cd		 mov	 ecx, ebp
  001d3	83 e1 0f	 and	 ecx, 15
  001d6	83 c1 08	 add	 ecx, 8
  001d9	85 c0		 test	 eax, eax
  001db	75 06		 jne	 SHORT $LN344@inflate

; 691  :                 state->wbits = len;

  001dd	41 89 4d 30	 mov	 DWORD PTR [r13+48], ecx
  001e1	8b c1		 mov	 eax, ecx
$LN344@inflate:

; 692  :             if (len > 15 || len > state->wbits) {

  001e3	83 f9 0f	 cmp	 ecx, 15
  001e6	77 45		 ja	 SHORT $LN346@inflate
  001e8	3b c8		 cmp	 ecx, eax
  001ea	77 41		 ja	 SHORT $LN346@inflate

; 696  :             }
; 697  :             state->dmax = 1U << len;

  001ec	b8 01 00 00 00	 mov	 eax, 1

; 698  :             state->flags = 0;               /* indicate zlib header */

  001f1	45 89 7d 18	 mov	 DWORD PTR [r13+24], r15d
  001f5	d3 e0		 shl	 eax, cl

; 699  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 700  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001f7	45 33 c0	 xor	 r8d, r8d
  001fa	33 c9		 xor	 ecx, ecx
  001fc	41 89 45 1c	 mov	 DWORD PTR [r13+28], eax
  00200	33 d2		 xor	 edx, edx
  00202	e8 00 00 00 00	 call	 adler32

; 701  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00207	c1 ed 08	 shr	 ebp, 8

; 702  :             INITBITS();

  0020a	41 8b df	 mov	 ebx, r15d
  0020d	f7 d5		 not	 ebp
  0020f	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00213	83 e5 02	 and	 ebp, 2
  00216	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  0021b	81 cd 3d 3f 00
	00		 or	 ebp, 16189		; 00003f3dH
  00221	41 89 6d 08	 mov	 DWORD PTR [r13+8], ebp
  00225	41 8b ef	 mov	 ebp, r15d

; 703  :             break;

  00228	e9 37 05 00 00	 jmp	 $LN930@inflate
$LN346@inflate:

; 693  :                 strm->msg = (char *)"invalid window size";

  0022d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size@
  00234	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 694  :                 state->mode = BAD;

  00239	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 695  :                 break;

  00241	e9 28 05 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 675  : #else
; 676  :             if (
; 677  : #endif
; 678  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 679  :                 strm->msg = (char *)"incorrect header check";

  00246	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
  0024d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 680  :                 state->mode = BAD;

  00252	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 681  :                 break;

  0025a	e9 0f 05 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 704  : #ifdef GUNZIP
; 705  :         case FLAGS:
; 706  :             NEEDBITS(16);

  0025f	83 fb 10	 cmp	 ebx, 16
  00262	73 1e		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00264	85 ff		 test	 edi, edi
  00266	0f 84 81 06 00
	00		 je	 $LN963@inflate
  0026c	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0026f	8b cb		 mov	 ecx, ebx
  00271	d3 e0		 shl	 eax, cl
  00273	ff cf		 dec	 edi
  00275	03 e8		 add	 ebp, eax
  00277	48 ff c6	 inc	 rsi
  0027a	83 c3 08	 add	 ebx, 8
  0027d	83 fb 10	 cmp	 ebx, 16
  00280	72 e2		 jb	 SHORT $LL33@inflate
$LN30@inflate:

; 707  :             state->flags = (int)(hold);

  00282	41 89 6d 18	 mov	 DWORD PTR [r13+24], ebp

; 708  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00286	40 80 fd 08	 cmp	 bpl, 8
  0028a	74 19		 je	 SHORT $LN349@inflate

; 709  :                 strm->msg = (char *)"unknown compression method";

  0028c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  00293	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 710  :                 state->mode = BAD;

  00298	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 711  :                 break;

  002a0	e9 c9 04 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 712  :             }
; 713  :             if (state->flags & 0xe000) {

  002a5	f7 c5 00 e0 00
	00		 test	 ebp, 57344		; 0000e000H
  002ab	74 19		 je	 SHORT $LN350@inflate

; 714  :                 strm->msg = (char *)"unknown header flags set";

  002ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002b4	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 715  :                 state->mode = BAD;

  002b9	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 716  :                 break;

  002c1	e9 a8 04 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 717  :             }
; 718  :             if (state->head != Z_NULL)

  002c6	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  002ca	8b cd		 mov	 ecx, ebp
  002cc	c1 e9 08	 shr	 ecx, 8
  002cf	8b c5		 mov	 eax, ebp
  002d1	48 85 d2	 test	 rdx, rdx
  002d4	74 0b		 je	 SHORT $LN654@inflate

; 719  :                 state->head->text = (int)((hold >> 8) & 1);

  002d6	8b c1		 mov	 eax, ecx
  002d8	83 e0 01	 and	 eax, 1
  002db	89 02		 mov	 DWORD PTR [rdx], eax
  002dd	41 8b 45 18	 mov	 eax, DWORD PTR [r13+24]
$LN654@inflate:

; 720  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002e1	0f ba e0 09	 bt	 eax, 9
  002e5	73 28		 jae	 SHORT $LN39@inflate
  002e7	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  002ec	74 21		 je	 SHORT $LN39@inflate

; 721  :                 CRC2(state->check, hold);

  002ee	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  002f2	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  002f7	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  002fb	41 b8 02 00 00
	00		 mov	 r8d, 2
  00301	40 88 6c 24 34	 mov	 BYTE PTR hbuf$[rsp], bpl
  00306	e8 00 00 00 00	 call	 crc32
  0030b	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN39@inflate:

; 722  :             INITBITS();

  0030f	41 8b ef	 mov	 ebp, r15d

; 723  :             state->mode = TIME;

  00312	41 c7 45 08 36
	3f 00 00	 mov	 DWORD PTR [r13+8], 16182 ; 00003f36H
  0031a	41 8b df	 mov	 ebx, r15d

; 724  :                 /* fallthrough */
; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0031d	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  0031f	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00322	73 1e		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00324	85 ff		 test	 edi, edi
  00326	0f 84 c1 05 00
	00		 je	 $LN963@inflate
  0032c	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0032f	8b cb		 mov	 ecx, ebx
  00331	d3 e0		 shl	 eax, cl
  00333	ff cf		 dec	 edi
  00335	03 e8		 add	 ebp, eax
  00337	48 ff c6	 inc	 rsi
  0033a	83 c3 08	 add	 ebx, 8
  0033d	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00340	72 e2		 jb	 SHORT $LL47@inflate
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  00342	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00346	48 85 c0	 test	 rax, rax
  00349	74 03		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  0034b	89 68 04	 mov	 DWORD PTR [rax+4], ebp
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0034e	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00356	74 3e		 je	 SHORT $LN53@inflate
  00358	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0035d	74 37		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  0035f	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00363	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00368	8b c5		 mov	 eax, ebp
  0036a	40 88 6c 24 34	 mov	 BYTE PTR hbuf$[rsp], bpl
  0036f	c1 e8 08	 shr	 eax, 8
  00372	41 b8 04 00 00
	00		 mov	 r8d, 4
  00378	88 44 24 35	 mov	 BYTE PTR hbuf$[rsp+1], al
  0037c	8b c5		 mov	 eax, ebp
  0037e	c1 e8 10	 shr	 eax, 16
  00381	c1 ed 18	 shr	 ebp, 24
  00384	88 44 24 36	 mov	 BYTE PTR hbuf$[rsp+2], al
  00388	40 88 6c 24 37	 mov	 BYTE PTR hbuf$[rsp+3], bpl
  0038d	e8 00 00 00 00	 call	 crc32
  00392	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN53@inflate:

; 731  :             INITBITS();

  00396	41 8b ef	 mov	 ebp, r15d

; 732  :             state->mode = OS;

  00399	41 c7 45 08 37
	3f 00 00	 mov	 DWORD PTR [r13+8], 16183 ; 00003f37H
  003a1	41 8b df	 mov	 ebx, r15d

; 733  :                 /* fallthrough */
; 734  :         case OS:
; 735  :             NEEDBITS(16);

  003a4	eb 0a		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  003a6	83 fb 10	 cmp	 ebx, 16
  003a9	73 23		 jae	 SHORT $LN58@inflate
  003ab	0f 1f 44 00 00	 npad	 5
$LL61@inflate:
  003b0	85 ff		 test	 edi, edi
  003b2	0f 84 35 05 00
	00		 je	 $LN963@inflate
  003b8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  003bb	8b cb		 mov	 ecx, ebx
  003bd	d3 e0		 shl	 eax, cl
  003bf	ff cf		 dec	 edi
  003c1	03 e8		 add	 ebp, eax
  003c3	48 ff c6	 inc	 rsi
  003c6	83 c3 08	 add	 ebx, 8
  003c9	83 fb 10	 cmp	 ebx, 16
  003cc	72 e2		 jb	 SHORT $LL61@inflate
$LN58@inflate:

; 736  :             if (state->head != Z_NULL) {

  003ce	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  003d2	48 85 c9	 test	 rcx, rcx
  003d5	74 15		 je	 SHORT $LN752@inflate

; 737  :                 state->head->xflags = (int)(hold & 0xff);

  003d7	40 0f b6 c5	 movzx	 eax, bpl
  003db	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 738  :                 state->head->os = (int)(hold >> 8);

  003de	8b cd		 mov	 ecx, ebp
  003e0	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  003e4	c1 e9 08	 shr	 ecx, 8
  003e7	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
  003ea	eb 05		 jmp	 SHORT $LN655@inflate
$LN752@inflate:
  003ec	8b cd		 mov	 ecx, ebp
  003ee	c1 e9 08	 shr	 ecx, 8
$LN655@inflate:

; 739  :             }
; 740  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003f1	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  003f9	74 28		 je	 SHORT $LN67@inflate
  003fb	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00400	74 21		 je	 SHORT $LN67@inflate

; 741  :                 CRC2(state->check, hold);

  00402	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  00406	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0040b	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0040f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00415	40 88 6c 24 34	 mov	 BYTE PTR hbuf$[rsp], bpl
  0041a	e8 00 00 00 00	 call	 crc32
  0041f	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN67@inflate:

; 742  :             INITBITS();

  00423	41 8b ef	 mov	 ebp, r15d

; 743  :             state->mode = EXLEN;

  00426	41 c7 45 08 38
	3f 00 00	 mov	 DWORD PTR [r13+8], 16184 ; 00003f38H
  0042e	41 8b df	 mov	 ebx, r15d
$LN361@inflate:

; 744  :                 /* fallthrough */
; 745  :         case EXLEN:
; 746  :             if (state->flags & 0x0400) {

  00431	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  00439	74 71		 je	 SHORT $LN362@inflate

; 747  :                 NEEDBITS(16);

  0043b	83 fb 10	 cmp	 ebx, 16
  0043e	73 1e		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00440	85 ff		 test	 edi, edi
  00442	0f 84 a5 04 00
	00		 je	 $LN963@inflate
  00448	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0044b	8b cb		 mov	 ecx, ebx
  0044d	d3 e0		 shl	 eax, cl
  0044f	ff cf		 dec	 edi
  00451	03 e8		 add	 ebp, eax
  00453	48 ff c6	 inc	 rsi
  00456	83 c3 08	 add	 ebx, 8
  00459	83 fb 10	 cmp	 ebx, 16
  0045c	72 e2		 jb	 SHORT $LL75@inflate
$LN72@inflate:

; 748  :                 state->length = (unsigned)(hold);
; 749  :                 if (state->head != Z_NULL)

  0045e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00462	41 89 6d 50	 mov	 DWORD PTR [r13+80], ebp
  00466	48 85 c0	 test	 rax, rax
  00469	74 03		 je	 SHORT $LN365@inflate

; 750  :                     state->head->extra_len = (unsigned)hold;

  0046b	89 68 18	 mov	 DWORD PTR [rax+24], ebp
$LN365@inflate:

; 751  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  0046e	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00476	74 2c		 je	 SHORT $LN81@inflate
  00478	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0047d	74 25		 je	 SHORT $LN81@inflate

; 752  :                     CRC2(state->check, hold);

  0047f	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00483	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00488	40 88 6c 24 34	 mov	 BYTE PTR hbuf$[rsp], bpl
  0048d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00493	c1 ed 08	 shr	 ebp, 8
  00496	40 88 6c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], bpl
  0049b	e8 00 00 00 00	 call	 crc32
  004a0	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN81@inflate:

; 753  :                 INITBITS();

  004a4	41 8b ef	 mov	 ebp, r15d
  004a7	41 8b df	 mov	 ebx, r15d

; 754  :             }

  004aa	eb 0d		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 755  :             else if (state->head != Z_NULL)

  004ac	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004b0	48 85 c0	 test	 rax, rax
  004b3	74 04		 je	 SHORT $LN367@inflate

; 756  :                 state->head->extra = Z_NULL;

  004b5	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN367@inflate:

; 757  :             state->mode = EXTRA;

  004b9	41 c7 45 08 39
	3f 00 00	 mov	 DWORD PTR [r13+8], 16185 ; 00003f39H
$LN368@inflate:

; 758  :                 /* fallthrough */
; 759  :         case EXTRA:
; 760  :             if (state->flags & 0x0400) {

  004c1	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  004c5	0f ba e1 0a	 bt	 ecx, 10
  004c9	0f 83 a0 00 00
	00		 jae	 $LN374@inflate

; 761  :                 copy = state->length;

  004cf	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 762  :                 if (copy > have) copy = have;
; 763  :                 if (copy) {

  004d3	44 8b f7	 mov	 r14d, edi
  004d6	3b c7		 cmp	 eax, edi
  004d8	44 0f 46 f0	 cmovbe	 r14d, eax
  004dc	45 85 f6	 test	 r14d, r14d
  004df	0f 84 82 00 00
	00		 je	 $LN371@inflate

; 764  :                     if (state->head != Z_NULL &&

  004e5	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  004e9	44 8b f8	 mov	 r15d, eax
  004ec	48 85 d2	 test	 rdx, rdx
  004ef	74 40		 je	 SHORT $LN372@inflate
  004f1	4c 8b 52 10	 mov	 r10, QWORD PTR [rdx+16]
  004f5	4d 85 d2	 test	 r10, r10
  004f8	74 37		 je	 SHORT $LN372@inflate

; 765  :                         state->head->extra != Z_NULL) {
; 766  :                         len = state->head->extra_len - state->length;
; 767  :                         zmemcpy(state->head->extra + len, next,

  004fa	44 8b 42 1c	 mov	 r8d, DWORD PTR [rdx+28]
  004fe	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]
  00502	41 8b d0	 mov	 edx, r8d
  00505	44 2b c8	 sub	 r9d, eax
  00508	41 8b c6	 mov	 eax, r14d
  0050b	41 2b d1	 sub	 edx, r9d
  0050e	43 8d 0c 0e	 lea	 ecx, DWORD PTR [r14+r9]
  00512	41 3b c8	 cmp	 ecx, r8d
  00515	41 8b c9	 mov	 ecx, r9d
  00518	0f 47 c2	 cmova	 eax, edx
  0051b	49 03 ca	 add	 rcx, r10
  0051e	44 8b c0	 mov	 r8d, eax
  00521	48 8b d6	 mov	 rdx, rsi
  00524	e8 00 00 00 00	 call	 memcpy
  00529	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  0052d	45 8b 7d 50	 mov	 r15d, DWORD PTR [r13+80]
$LN372@inflate:

; 768  :                                 len + copy > state->head->extra_max ?
; 769  :                                 state->head->extra_max - len : copy);
; 770  :                     }
; 771  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00531	0f ba e1 09	 bt	 ecx, 9
  00535	73 1a		 jae	 SHORT $LN373@inflate
  00537	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0053c	74 13		 je	 SHORT $LN373@inflate

; 772  :                         state->check = crc32(state->check, next, copy);

  0053e	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00542	45 8b c6	 mov	 r8d, r14d
  00545	48 8b d6	 mov	 rdx, rsi
  00548	e8 00 00 00 00	 call	 crc32
  0054d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN373@inflate:

; 773  :                     have -= copy;
; 774  :                     next += copy;

  00551	41 8b c6	 mov	 eax, r14d
  00554	41 2b fe	 sub	 edi, r14d
  00557	48 03 f0	 add	 rsi, rax

; 775  :                     state->length -= copy;

  0055a	41 8b c7	 mov	 eax, r15d
  0055d	41 2b c6	 sub	 eax, r14d
  00560	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
  00564	45 33 ff	 xor	 r15d, r15d
$LN371@inflate:

; 776  :                 }
; 777  :                 if (state->length) goto inf_leave;

  00567	85 c0		 test	 eax, eax
  00569	0f 85 7e 03 00
	00		 jne	 $LN963@inflate
$LN374@inflate:

; 778  :             }
; 779  :             state->length = 0;

  0056f	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 780  :             state->mode = NAME;

  00573	41 c7 45 08 3a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16186 ; 00003f3aH
$LN375@inflate:

; 781  :                 /* fallthrough */
; 782  :         case NAME:
; 783  :             if (state->flags & 0x0800) {

  0057b	41 f7 45 18 00
	08 00 00	 test	 DWORD PTR [r13+24], 2048 ; 00000800H
  00583	74 7e		 je	 SHORT $LN376@inflate

; 784  :                 if (have == 0) goto inf_leave;

  00585	85 ff		 test	 edi, edi
  00587	0f 84 60 03 00
	00		 je	 $LN963@inflate

; 785  :                 copy = 0;

  0058d	45 8b f7	 mov	 r14d, r15d
$LL88@inflate:

; 786  :                 do {
; 787  :                     len = (unsigned)(next[copy++]);

  00590	41 8b c6	 mov	 eax, r14d
  00593	41 ff c6	 inc	 r14d
  00596	44 0f b6 3c 30	 movzx	 r15d, BYTE PTR [rax+rsi]

; 788  :                     if (state->head != Z_NULL &&
; 789  :                             state->head->name != Z_NULL &&

  0059b	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0059f	48 85 c0	 test	 rax, rax
  005a2	74 1a		 je	 SHORT $LN86@inflate
  005a4	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  005a8	48 85 d2	 test	 rdx, rdx
  005ab	74 11		 je	 SHORT $LN86@inflate
  005ad	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  005b1	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  005b4	73 08		 jae	 SHORT $LN86@inflate

; 790  :                             state->length < state->head->name_max)
; 791  :                         state->head->name[state->length++] = (Bytef)len;

  005b6	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  005ba	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN86@inflate:

; 792  :                 } while (len && copy < have);

  005be	45 84 ff	 test	 r15b, r15b
  005c1	74 05		 je	 SHORT $LN380@inflate
  005c3	44 3b f7	 cmp	 r14d, edi
  005c6	72 c8		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 793  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005c8	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  005d0	74 1a		 je	 SHORT $LN381@inflate
  005d2	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  005d7	74 13		 je	 SHORT $LN381@inflate

; 794  :                     state->check = crc32(state->check, next, copy);

  005d9	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  005dd	45 8b c6	 mov	 r8d, r14d
  005e0	48 8b d6	 mov	 rdx, rsi
  005e3	e8 00 00 00 00	 call	 crc32
  005e8	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN381@inflate:

; 795  :                 have -= copy;
; 796  :                 next += copy;

  005ec	41 8b c6	 mov	 eax, r14d
  005ef	41 2b fe	 sub	 edi, r14d
  005f2	48 03 f0	 add	 rsi, rax

; 797  :                 if (len) goto inf_leave;

  005f5	45 84 ff	 test	 r15b, r15b
  005f8	0f 85 ef 02 00
	00		 jne	 $LN963@inflate

; 798  :             }

  005fe	45 33 ff	 xor	 r15d, r15d
  00601	eb 0d		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 799  :             else if (state->head != Z_NULL)

  00603	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00607	48 85 c0	 test	 rax, rax
  0060a	74 04		 je	 SHORT $LN383@inflate

; 800  :                 state->head->name = Z_NULL;

  0060c	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN383@inflate:

; 801  :             state->length = 0;

  00610	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 802  :             state->mode = COMMENT;

  00614	41 c7 45 08 3b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16187 ; 00003f3bH
$LN384@inflate:

; 803  :                 /* fallthrough */
; 804  :         case COMMENT:
; 805  :             if (state->flags & 0x1000) {

  0061c	41 f7 45 18 00
	10 00 00	 test	 DWORD PTR [r13+24], 4096 ; 00001000H
  00624	0f 84 89 00 00
	00		 je	 $LN385@inflate

; 806  :                 if (have == 0) goto inf_leave;

  0062a	85 ff		 test	 edi, edi
  0062c	0f 84 bb 02 00
	00		 je	 $LN963@inflate

; 807  :                 copy = 0;

  00632	45 8b f7	 mov	 r14d, r15d
  00635	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL91@inflate:

; 808  :                 do {
; 809  :                     len = (unsigned)(next[copy++]);

  00640	41 8b c6	 mov	 eax, r14d
  00643	41 ff c6	 inc	 r14d
  00646	44 0f b6 3c 30	 movzx	 r15d, BYTE PTR [rax+rsi]

; 810  :                     if (state->head != Z_NULL &&
; 811  :                             state->head->comment != Z_NULL &&

  0064b	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0064f	48 85 c0	 test	 rax, rax
  00652	74 1a		 je	 SHORT $LN89@inflate
  00654	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00658	48 85 d2	 test	 rdx, rdx
  0065b	74 11		 je	 SHORT $LN89@inflate
  0065d	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  00661	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00664	73 08		 jae	 SHORT $LN89@inflate

; 812  :                             state->length < state->head->comm_max)
; 813  :                         state->head->comment[state->length++] = (Bytef)len;

  00666	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  0066a	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN89@inflate:

; 814  :                 } while (len && copy < have);

  0066e	45 84 ff	 test	 r15b, r15b
  00671	74 05		 je	 SHORT $LN389@inflate
  00673	44 3b f7	 cmp	 r14d, edi
  00676	72 c8		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 815  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00678	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00680	74 1a		 je	 SHORT $LN390@inflate
  00682	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00687	74 13		 je	 SHORT $LN390@inflate

; 816  :                     state->check = crc32(state->check, next, copy);

  00689	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0068d	45 8b c6	 mov	 r8d, r14d
  00690	48 8b d6	 mov	 rdx, rsi
  00693	e8 00 00 00 00	 call	 crc32
  00698	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN390@inflate:

; 817  :                 have -= copy;
; 818  :                 next += copy;

  0069c	41 8b c6	 mov	 eax, r14d
  0069f	41 2b fe	 sub	 edi, r14d
  006a2	48 03 f0	 add	 rsi, rax

; 819  :                 if (len) goto inf_leave;

  006a5	45 84 ff	 test	 r15b, r15b
  006a8	0f 85 3f 02 00
	00		 jne	 $LN963@inflate

; 820  :             }

  006ae	45 33 ff	 xor	 r15d, r15d
  006b1	eb 0d		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 821  :             else if (state->head != Z_NULL)

  006b3	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  006b7	48 85 c0	 test	 rax, rax
  006ba	74 04		 je	 SHORT $LN392@inflate

; 822  :                 state->head->comment = Z_NULL;

  006bc	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN392@inflate:
  006c0	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]

; 823  :             state->mode = HCRC;

  006c5	41 c7 45 08 3c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16188 ; 00003f3cH
$LN393@inflate:

; 824  :                 /* fallthrough */
; 825  :         case HCRC:
; 826  :             if (state->flags & 0x0200) {

  006cd	41 8b 55 18	 mov	 edx, DWORD PTR [r13+24]
  006d1	0f ba e2 09	 bt	 edx, 9
  006d5	73 53		 jae	 SHORT $LN101@inflate

; 827  :                 NEEDBITS(16);

  006d7	83 fb 10	 cmp	 ebx, 16
  006da	73 22		 jae	 SHORT $LN92@inflate
  006dc	0f 1f 40 00	 npad	 4
$LL95@inflate:
  006e0	85 ff		 test	 edi, edi
  006e2	0f 84 05 02 00
	00		 je	 $LN963@inflate
  006e8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  006eb	8b cb		 mov	 ecx, ebx
  006ed	d3 e0		 shl	 eax, cl
  006ef	ff cf		 dec	 edi
  006f1	03 e8		 add	 ebp, eax
  006f3	48 ff c6	 inc	 rsi
  006f6	83 c3 08	 add	 ebx, 8
  006f9	83 fb 10	 cmp	 ebx, 16
  006fc	72 e2		 jb	 SHORT $LL95@inflate
$LN92@inflate:

; 828  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  006fe	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00703	74 1f		 je	 SHORT $LN102@inflate
  00705	41 0f b7 45 20	 movzx	 eax, WORD PTR [r13+32]
  0070a	3b e8		 cmp	 ebp, eax
  0070c	74 16		 je	 SHORT $LN102@inflate

; 829  :                     strm->msg = (char *)"header crc mismatch";

  0070e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  00715	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 830  :                     state->mode = BAD;

  0071a	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 831  :                     break;

  00722	eb 45		 jmp	 SHORT $LN996@inflate
$LN102@inflate:

; 832  :                 }
; 833  :                 INITBITS();

  00724	41 8b ef	 mov	 ebp, r15d
  00727	41 8b df	 mov	 ebx, r15d
$LN101@inflate:

; 834  :             }
; 835  :             if (state->head != Z_NULL) {

  0072a	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0072e	48 85 c0	 test	 rax, rax
  00731	74 14		 je	 SHORT $LN397@inflate

; 836  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00733	c1 fa 09	 sar	 edx, 9
  00736	83 e2 01	 and	 edx, 1
  00739	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 837  :                 state->head->done = 1;

  0073c	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00740	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 838  :             }
; 839  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00747	45 33 c0	 xor	 r8d, r8d
  0074a	33 d2		 xor	 edx, edx
  0074c	33 c9		 xor	 ecx, ecx
  0074e	e8 00 00 00 00	 call	 crc32
  00753	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00757	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN998@inflate:

; 651  :     in = have;
; 652  :     out = left;
; 653  :     ret = Z_OK;
; 654  :     for (;;)
; 655  :         switch (state->mode) {

  0075c	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN930@inflate:
  00764	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
$LN996@inflate:
  00769	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
$LN8@inflate:
  0076e	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  00772	8d 82 cc c0 ff
	ff		 lea	 eax, DWORD PTR [rdx-16180]
  00778	83 f8 1f	 cmp	 eax, 31
  0077b	0f 87 d8 0f 00
	00		 ja	 $LN333@inflate
  00781	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  00789	45 33 ff	 xor	 r15d, r15d
  0078c	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR flush$[rsp]
  00794	e9 1b f9 ff ff	 jmp	 $LN999@inflate
$LN105@inflate:

; 840  :             state->mode = TYPE;
; 841  :             break;
; 842  : #endif
; 843  :         case DICTID:
; 844  :             NEEDBITS(32);

  00799	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0079c	73 20		 jae	 SHORT $LN103@inflate
  0079e	66 90		 npad	 2
$LL106@inflate:
  007a0	85 ff		 test	 edi, edi
  007a2	0f 84 45 01 00
	00		 je	 $LN963@inflate
  007a8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  007ab	8b cb		 mov	 ecx, ebx
  007ad	d3 e0		 shl	 eax, cl
  007af	ff cf		 dec	 edi
  007b1	03 e8		 add	 ebp, eax
  007b3	48 ff c6	 inc	 rsi
  007b6	83 c3 08	 add	 ebx, 8
  007b9	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007bc	72 e2		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 845  :             strm->adler = state->check = ZSWAP32(hold);

  007be	8b cd		 mov	 ecx, ebp
  007c0	8b c5		 mov	 eax, ebp
  007c2	c1 e0 10	 shl	 eax, 16
  007c5	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007cb	03 c8		 add	 ecx, eax

; 846  :             INITBITS();

  007cd	41 8b df	 mov	 ebx, r15d
  007d0	8b c5		 mov	 eax, ebp
  007d2	c1 e1 08	 shl	 ecx, 8
  007d5	c1 e8 08	 shr	 eax, 8
  007d8	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007dd	c1 ed 18	 shr	 ebp, 24
  007e0	03 c1		 add	 eax, ecx
  007e2	03 c5		 add	 eax, ebp
  007e4	41 8b ef	 mov	 ebp, r15d
  007e7	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  007eb	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 847  :             state->mode = DICT;

  007f0	41 c7 45 08 3e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16190 ; 00003f3eH
$LN400@inflate:

; 848  :                 /* fallthrough */
; 849  :         case DICT:
; 850  :             if (state->havedict == 0) {

  007f8	41 83 7d 14 00	 cmp	 DWORD PTR [r13+20], 0
  007fd	0f 84 10 0e 00
	00		 je	 $LN587@inflate

; 853  :             }
; 854  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00803	45 33 c0	 xor	 r8d, r8d
  00806	33 d2		 xor	 edx, edx
  00808	33 c9		 xor	 ecx, ecx
  0080a	e8 00 00 00 00	 call	 adler32
  0080f	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  00814	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00818	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 855  :             state->mode = TYPE;

  0081d	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN402@inflate:

; 856  :                 /* fallthrough */
; 857  :         case TYPE:
; 858  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00825	41 8d 46 fb	 lea	 eax, DWORD PTR [r14-5]
  00829	83 f8 01	 cmp	 eax, 1
  0082c	0f 86 bb 00 00
	00		 jbe	 $LN963@inflate
$LN403@inflate:

; 859  :                 /* fallthrough */
; 860  :         case TYPEDO:
; 861  :             if (state->last) {

  00832	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00837	74 16		 je	 SHORT $LN122@inflate

; 862  :                 BYTEBITS();

  00839	8b cb		 mov	 ecx, ebx

; 863  :                 state->mode = CHECK;

  0083b	41 c7 45 08 4e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16206 ; 00003f4eH
  00843	83 e1 07	 and	 ecx, 7
  00846	d3 ed		 shr	 ebp, cl
  00848	2b d9		 sub	 ebx, ecx

; 864  :                 break;

  0084a	e9 1a ff ff ff	 jmp	 $LN996@inflate
$LN122@inflate:

; 865  :             }
; 866  :             NEEDBITS(3);

  0084f	83 fb 03	 cmp	 ebx, 3
  00852	73 1e		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00854	85 ff		 test	 edi, edi
  00856	0f 84 91 00 00
	00		 je	 $LN963@inflate
  0085c	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0085f	8b cb		 mov	 ecx, ebx
  00861	d3 e0		 shl	 eax, cl
  00863	ff cf		 dec	 edi
  00865	03 e8		 add	 ebp, eax
  00867	48 ff c6	 inc	 rsi
  0086a	83 c3 08	 add	 ebx, 8
  0086d	83 fb 03	 cmp	 ebx, 3
  00870	72 e2		 jb	 SHORT $LL123@inflate
$LN120@inflate:

; 867  :             state->last = BITS(1);

  00872	8b c5		 mov	 eax, ebp

; 868  :             DROPBITS(1);

  00874	d1 ed		 shr	 ebp, 1
  00876	83 e0 01	 and	 eax, 1
  00879	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 869  :             switch (BITS(2)) {

  0087d	8b c5		 mov	 eax, ebp
  0087f	83 e0 03	 and	 eax, 3
  00882	0f 84 00 01 00
	00		 je	 $LN408@inflate
  00888	83 e8 01	 sub	 eax, 1
  0088b	74 40		 je	 SHORT $LN409@inflate
  0088d	83 e8 01	 sub	 eax, 1
  00890	74 28		 je	 SHORT $LN411@inflate
  00892	83 f8 01	 cmp	 eax, 1
  00895	0f 85 f5 00 00
	00		 jne	 $LN138@inflate

; 882  :                     goto inf_leave;
; 883  :                 }
; 884  :                 break;
; 885  :             case 2:                             /* dynamic block */
; 886  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 887  :                         state->last ? " (last)" : ""));
; 888  :                 state->mode = TABLE;
; 889  :                 break;
; 890  :             case 3:
; 891  :                 strm->msg = (char *)"invalid block type";

  0089b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 892  :                 state->mode = BAD;
; 893  :             }
; 894  :             DROPBITS(2);

  008a2	c1 ed 02	 shr	 ebp, 2
  008a5	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  008aa	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008ad	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 895  :             break;

  008b5	e9 af fe ff ff	 jmp	 $LN996@inflate
$LN411@inflate:

; 892  :                 state->mode = BAD;
; 893  :             }
; 894  :             DROPBITS(2);

  008ba	c1 ed 02	 shr	 ebp, 2
  008bd	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008c0	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H

; 895  :             break;

  008c8	e9 9c fe ff ff	 jmp	 $LN996@inflate
$LN409@inflate:

; 874  :                 break;
; 875  :             case 1:                             /* fixed block */
; 876  :                 fixedtables(state);

  008cd	49 8b cd	 mov	 rcx, r13
  008d0	e8 00 00 00 00	 call	 fixedtables

; 877  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = LEN_;             /* decode codes */

  008d5	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H

; 880  :                 if (flush == Z_TREES) {

  008dd	41 83 fe 06	 cmp	 r14d, 6
  008e1	0f 85 a9 00 00
	00		 jne	 $LN138@inflate

; 881  :                     DROPBITS(2);

  008e7	c1 ed 02	 shr	 ebp, 2
  008ea	83 c3 fd	 add	 ebx, -3			; fffffffdH
$LN963@inflate:

; 1260 :             goto inf_leave;
; 1261 :         case MEM:
; 1262 :             return Z_MEM_ERROR;
; 1263 :         case SYNC:
; 1264 :                 /* fallthrough */
; 1265 :         default:
; 1266 :             return Z_STREAM_ERROR;
; 1267 :         }
; 1268 : 
; 1269 :     /*
; 1270 :        Return from inflate(), updating the total counts and the check value.
; 1271 :        If there was no progress during the inflate() call, return a buffer
; 1272 :        error.  Call updatewindow() to create and/or update the window state.
; 1273 :        Note: a memory error from inflate() is non-recoverable.
; 1274 :      */
; 1275 :   inf_leave:
; 1276 :     RESTORE();

  008ed	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR out$1$[rsp]
$LN967@inflate:
  008f5	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR ret$1$[rsp]
$LN1000@inflate:
  008fd	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
$inf_leave$1003:
  00904	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$1$[rsp]
  00909	8b 44 24 30	 mov	 eax, DWORD PTR left$1$[rsp]
  0090d	49 89 4c 24 10	 mov	 QWORD PTR [r12+16], rcx
  00912	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  00917	49 89 34 24	 mov	 QWORD PTR [r12], rsi
  0091b	41 89 7c 24 08	 mov	 DWORD PTR [r12+8], edi

; 1277 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  00920	41 83 7d 34 00	 cmp	 DWORD PTR [r13+52], 0
  00925	41 89 6d 48	 mov	 DWORD PTR [r13+72], ebp
  00929	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  0092d	75 2a		 jne	 SHORT $LN503@inflate
  0092f	45 3b 74 24 18	 cmp	 r14d, DWORD PTR [r12+24]
  00934	0f 84 4a 0d 00
	00		 je	 $LN504@inflate
  0093a	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  0093e	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00943	0f 8d 3b 0d 00
	00		 jge	 $LN504@inflate
  00949	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0094e	7c 09		 jl	 SHORT $LN503@inflate
  00950	83 fa 04	 cmp	 edx, 4
  00953	0f 84 2b 0d 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1278 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1279 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00959	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  0095e	45 8b c6	 mov	 r8d, r14d
  00961	45 2b 44 24 18	 sub	 r8d, DWORD PTR [r12+24]
  00966	49 8b cc	 mov	 rcx, r12
  00969	e8 00 00 00 00	 call	 updatewindow
  0096e	85 c0		 test	 eax, eax
  00970	0f 84 0e 0d 00
	00		 je	 $LN504@inflate

; 1280 :             state->mode = MEM;

  00976	41 c7 45 08 52
	3f 00 00	 mov	 DWORD PTR [r13+8], 16210 ; 00003f52H
$LN498@inflate:

; 1297 : }

  0097e	b8 fc ff ff ff	 mov	 eax, -4
  00983	e9 d6 0d 00 00	 jmp	 $LN1@inflate
$LN408@inflate:

; 870  :             case 0:                             /* stored block */
; 871  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 872  :                         state->last ? " (last)" : ""));
; 873  :                 state->mode = STORED;

  00988	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN138@inflate:

; 892  :                 state->mode = BAD;
; 893  :             }
; 894  :             DROPBITS(2);

  00990	c1 ed 02	 shr	 ebp, 2
  00993	83 c3 fd	 add	 ebx, -3			; fffffffdH

; 895  :             break;

  00996	e9 ce fd ff ff	 jmp	 $LN996@inflate
$LN141@inflate:

; 896  :         case STORED:
; 897  :             BYTEBITS();                         /* go to byte boundary */

  0099b	8b cb		 mov	 ecx, ebx
  0099d	83 e1 07	 and	 ecx, 7
  009a0	d3 ed		 shr	 ebp, cl
  009a2	2b d9		 sub	 ebx, ecx

; 898  :             NEEDBITS(32);

  009a4	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009a7	73 25		 jae	 SHORT $LN142@inflate
  009a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL145@inflate:
  009b0	85 ff		 test	 edi, edi
  009b2	0f 84 35 ff ff
	ff		 je	 $LN963@inflate
  009b8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  009bb	8b cb		 mov	 ecx, ebx
  009bd	d3 e0		 shl	 eax, cl
  009bf	ff cf		 dec	 edi
  009c1	03 e8		 add	 ebp, eax
  009c3	48 ff c6	 inc	 rsi
  009c6	83 c3 08	 add	 ebx, 8
  009c9	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009cc	72 e2		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 899  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  009ce	8b c5		 mov	 eax, ebp
  009d0	0f b7 cd	 movzx	 ecx, bp
  009d3	f7 d0		 not	 eax
  009d5	c1 e8 10	 shr	 eax, 16
  009d8	3b c8		 cmp	 ecx, eax
  009da	74 19		 je	 SHORT $LN415@inflate

; 900  :                 strm->msg = (char *)"invalid stored block lengths";

  009dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  009e3	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 901  :                 state->mode = BAD;

  009e8	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 902  :                 break;

  009f0	e9 79 fd ff ff	 jmp	 $LN8@inflate
$LN415@inflate:

; 903  :             }
; 904  :             state->length = (unsigned)hold & 0xffff;

  009f5	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 905  :             Tracev((stderr, "inflate:       stored length %u\n",
; 906  :                     state->length));
; 907  :             INITBITS();

  009f9	41 8b ef	 mov	 ebp, r15d

; 908  :             state->mode = COPY_;

  009fc	41 c7 45 08 42
	3f 00 00	 mov	 DWORD PTR [r13+8], 16194 ; 00003f42H
  00a04	41 8b df	 mov	 ebx, r15d

; 909  :             if (flush == Z_TREES) goto inf_leave;

  00a07	41 83 fe 06	 cmp	 r14d, 6
  00a0b	0f 84 dc fe ff
	ff		 je	 $LN963@inflate
$LN416@inflate:

; 910  :                 /* fallthrough */
; 911  :         case COPY_:
; 912  :             state->mode = COPY;

  00a11	41 c7 45 08 43
	3f 00 00	 mov	 DWORD PTR [r13+8], 16195 ; 00003f43H
$LN418@inflate:

; 913  :                 /* fallthrough */
; 914  :         case COPY:
; 915  :             copy = state->length;

  00a19	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]

; 916  :             if (copy) {

  00a1d	85 c9		 test	 ecx, ecx
  00a1f	74 54		 je	 SHORT $LN419@inflate

; 917  :                 if (copy > have) copy = have;
; 918  :                 if (copy > left) copy = left;

  00a21	3b cf		 cmp	 ecx, edi
  00a23	8b c7		 mov	 eax, edi

; 919  :                 if (copy == 0) goto inf_leave;

  00a25	45 8b f2	 mov	 r14d, r10d
  00a28	0f 46 c1	 cmovbe	 eax, ecx
  00a2b	41 3b c2	 cmp	 eax, r10d
  00a2e	44 0f 46 f0	 cmovbe	 r14d, eax
  00a32	45 85 f6	 test	 r14d, r14d
  00a35	0f 84 b2 fe ff
	ff		 je	 $LN963@inflate

; 920  :                 zmemcpy(put, next, copy);

  00a3b	45 8b c6	 mov	 r8d, r14d
  00a3e	48 8b d6	 mov	 rdx, rsi
  00a41	49 8b c9	 mov	 rcx, r9
  00a44	e8 00 00 00 00	 call	 memcpy

; 921  :                 have -= copy;
; 922  :                 next += copy;
; 923  :                 left -= copy;

  00a49	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  00a4e	41 2b fe	 sub	 edi, r14d

; 924  :                 put += copy;

  00a51	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  00a56	45 2b d6	 sub	 r10d, r14d
  00a59	41 8b c6	 mov	 eax, r14d
  00a5c	4c 03 c8	 add	 r9, rax
  00a5f	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  00a64	48 03 f0	 add	 rsi, rax
  00a67	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9

; 925  :                 state->length -= copy;

  00a6c	45 29 75 50	 sub	 DWORD PTR [r13+80], r14d

; 926  :                 break;

  00a70	e9 f9 fc ff ff	 jmp	 $LN8@inflate
$LN419@inflate:

; 927  :             }
; 928  :             Tracev((stderr, "inflate:       stored end\n"));
; 929  :             state->mode = TYPE;

  00a75	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 930  :             break;

  00a7d	e9 ec fc ff ff	 jmp	 $LN8@inflate
$LN155@inflate:

; 931  :         case TABLE:
; 932  :             NEEDBITS(14);

  00a82	83 fb 0e	 cmp	 ebx, 14
  00a85	73 1e		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a87	85 ff		 test	 edi, edi
  00a89	0f 84 5e fe ff
	ff		 je	 $LN963@inflate
  00a8f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00a92	8b cb		 mov	 ecx, ebx
  00a94	d3 e0		 shl	 eax, cl
  00a96	ff cf		 dec	 edi
  00a98	03 e8		 add	 ebp, eax
  00a9a	48 ff c6	 inc	 rsi
  00a9d	83 c3 08	 add	 ebx, 8
  00aa0	83 fb 0e	 cmp	 ebx, 14
  00aa3	72 e2		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 933  :             state->nlen = BITS(5) + 257;

  00aa5	8b cd		 mov	 ecx, ebp

; 934  :             DROPBITS(5);
; 935  :             state->ndist = BITS(5) + 1;
; 936  :             DROPBITS(5);
; 937  :             state->ncode = BITS(4) + 4;
; 938  :             DROPBITS(4);

  00aa7	83 c3 f2	 add	 ebx, -14		; fffffff2H
  00aaa	c1 ed 05	 shr	 ebp, 5
  00aad	83 e1 1f	 and	 ecx, 31
  00ab0	8b d5		 mov	 edx, ebp
  00ab2	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00ab8	c1 ed 05	 shr	 ebp, 5
  00abb	83 e2 1f	 and	 edx, 31
  00abe	8b c5		 mov	 eax, ebp
  00ac0	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  00ac4	83 e0 0f	 and	 eax, 15
  00ac7	c1 ed 04	 shr	 ebp, 4
  00aca	83 c0 04	 add	 eax, 4
  00acd	ff c2		 inc	 edx
  00acf	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00ad6	41 89 45 78	 mov	 DWORD PTR [r13+120], eax

; 939  : #ifndef PKZIP_BUG_WORKAROUND
; 940  :             if (state->nlen > 286 || state->ndist > 30) {

  00ada	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00ae0	0f 87 2a 01 00
	00		 ja	 $LN426@inflate
  00ae6	83 fa 1e	 cmp	 edx, 30
  00ae9	0f 87 21 01 00
	00		 ja	 $LN426@inflate

; 944  :             }
; 945  : #endif
; 946  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 947  :             state->have = 0;

  00aef	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 948  :             state->mode = LENLENS;

  00af6	41 c7 45 08 45
	3f 00 00	 mov	 DWORD PTR [r13+8], 16197 ; 00003f45H
$LN533@inflate:

; 949  :                 /* fallthrough */
; 950  :         case LENLENS:
; 951  :             while (state->have < state->ncode) {

  00afe	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b05	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b09	73 62		 jae	 SHORT $LN535@inflate
  00b0b	0f 1f 44 00 00	 npad	 5
$LL170@inflate:

; 952  :                 NEEDBITS(3);

  00b10	83 fb 03	 cmp	 ebx, 3
  00b13	73 1e		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00b15	85 ff		 test	 edi, edi
  00b17	0f 84 d0 fd ff
	ff		 je	 $LN963@inflate
  00b1d	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00b20	8b cb		 mov	 ecx, ebx
  00b22	d3 e0		 shl	 eax, cl
  00b24	ff cf		 dec	 edi
  00b26	03 e8		 add	 ebp, eax
  00b28	48 ff c6	 inc	 rsi
  00b2b	83 c3 08	 add	 ebx, 8
  00b2e	83 fb 03	 cmp	 ebx, 3
  00b31	72 e2		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 953  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00b33	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b3a	0f b7 cd	 movzx	 ecx, bp
  00b3d	66 83 e1 07	 and	 cx, 7

; 954  :                 DROPBITS(3);

  00b41	c1 ed 03	 shr	 ebp, 3
  00b44	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00b47	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00b50	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  00b59	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00b60	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b67	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b6b	72 a3		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 955  :             }
; 956  :             while (state->have < 19)

  00b6d	83 f8 13	 cmp	 eax, 19
  00b70	73 38		 jae	 SHORT $LN184@inflate
  00b72	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL183@inflate:

; 957  :                 state->lens[order[state->have++]] = 0;

  00b80	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b87	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00b90	66 45 89 bc 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r15w
  00b99	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00ba0	41 83 bd 84 00
	00 00 13	 cmp	 DWORD PTR [r13+132], 19
  00ba8	72 d6		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 958  :             state->next = state->codes;
; 959  :             state->lencode = (const code FAR *)(state->next);
; 960  :             state->lenbits = 7;

  00baa	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  00bae	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  00bb5	c7 01 07 00 00
	00		 mov	 DWORD PTR [rcx], 7
  00bbb	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00bc2	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00bc6	49 89 01	 mov	 QWORD PTR [r9], rax

; 961  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00bc9	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00bd0	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  00bd7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00bdc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00be1	33 c9		 xor	 ecx, ecx
  00be3	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00be7	e8 00 00 00 00	 call	 inflate_table
  00bec	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax

; 962  :                                 &(state->lenbits), state->work);
; 963  :             if (ret) {

  00bf3	85 c0		 test	 eax, eax
  00bf5	74 32		 je	 SHORT $LN429@inflate

; 964  :                 strm->msg = (char *)"invalid code lengths set";

  00bf7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00bfe	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 965  :                 state->mode = BAD;

  00c03	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 966  :                 break;

  00c0b	e9 54 fb ff ff	 jmp	 $LN930@inflate
$LN426@inflate:

; 941  :                 strm->msg = (char *)"too many length or distance symbols";

  00c10	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00c17	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 942  :                 state->mode = BAD;

  00c1c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 943  :                 break;

  00c24	e9 45 fb ff ff	 jmp	 $LN8@inflate
$LN429@inflate:

; 967  :             }
; 968  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 969  :             state->have = 0;

  00c29	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 970  :             state->mode = CODELENS;

  00c30	ba 46 3f 00 00	 mov	 edx, 16198		; 00003f46H
  00c35	41 c7 45 08 46
	3f 00 00	 mov	 DWORD PTR [r13+8], 16198 ; 00003f46H
$LN536@inflate:

; 971  :                 /* fallthrough */
; 972  :         case CODELENS:
; 973  :             while (state->have < state->nlen + state->ndist) {

  00c3d	41 8b 8d 80 00
	00 00		 mov	 ecx, DWORD PTR [r13+128]
  00c44	45 8b 55 7c	 mov	 r10d, DWORD PTR [r13+124]
  00c48	41 03 ca	 add	 ecx, r10d
  00c4b	41 39 8d 84 00
	00 00		 cmp	 DWORD PTR [r13+132], ecx
  00c52	0f 83 fa 01 00
	00		 jae	 $LN186@inflate
  00c58	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL185@inflate:

; 974  :                 for (;;) {
; 975  :                     here = state->lencode[BITS(state->lenbits)];

  00c60	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  00c64	41 b9 01 00 00
	00		 mov	 r9d, 1
  00c6a	4d 8b 55 60	 mov	 r10, QWORD PTR [r13+96]
  00c6e	41 d3 e1	 shl	 r9d, cl
  00c71	41 ff c9	 dec	 r9d
  00c74	8b c5		 mov	 eax, ebp
  00c76	41 8b c9	 mov	 ecx, r9d
  00c79	48 23 c8	 and	 rcx, rax
  00c7c	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00c80	8b d0		 mov	 edx, eax
  00c82	c1 ea 08	 shr	 edx, 8
  00c85	44 8b c0	 mov	 r8d, eax
  00c88	0f b6 ca	 movzx	 ecx, dl
  00c8b	41 c1 e8 10	 shr	 r8d, 16
  00c8f	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax

; 976  :                     if ((unsigned)(here.bits) <= bits) break;

  00c93	3b cb		 cmp	 ecx, ebx
  00c95	76 3c		 jbe	 SHORT $LN656@inflate
$LL187@inflate:

; 977  :                     PULLBYTE();

  00c97	85 ff		 test	 edi, edi
  00c99	0f 84 4e fc ff
	ff		 je	 $LN963@inflate
  00c9f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00ca2	8b cb		 mov	 ecx, ebx
  00ca4	d3 e0		 shl	 eax, cl
  00ca6	ff cf		 dec	 edi
  00ca8	03 e8		 add	 ebp, eax
  00caa	48 ff c6	 inc	 rsi
  00cad	8b cd		 mov	 ecx, ebp
  00caf	83 c3 08	 add	 ebx, 8
  00cb2	41 8b c1	 mov	 eax, r9d
  00cb5	48 23 c1	 and	 rax, rcx
  00cb8	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00cbc	8b d0		 mov	 edx, eax
  00cbe	c1 ea 08	 shr	 edx, 8
  00cc1	44 8b c0	 mov	 r8d, eax
  00cc4	0f b6 ca	 movzx	 ecx, dl
  00cc7	41 c1 e8 10	 shr	 r8d, 16
  00ccb	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax
  00ccf	3b cb		 cmp	 ecx, ebx
  00cd1	77 c4		 ja	 SHORT $LL187@inflate
$LN656@inflate:

; 978  :                 }
; 979  :                 if (here.val < 16) {

  00cd3	66 41 83 f8 10	 cmp	 r8w, 16
  00cd8	73 30		 jae	 SHORT $LN433@inflate

; 980  :                     DROPBITS(here.bits);

  00cda	0f b6 ca	 movzx	 ecx, dl

; 981  :                     state->lens[state->have++] = here.val;

  00cdd	c1 e8 10	 shr	 eax, 16
  00ce0	d3 ed		 shr	 ebp, cl
  00ce2	0f b6 ca	 movzx	 ecx, dl
  00ce5	2b d9		 sub	 ebx, ecx
  00ce7	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00cee	66 41 89 84 4d
	90 00 00 00	 mov	 WORD PTR [r13+rcx*2+144], ax
  00cf7	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00cfe	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]

; 982  :                 }

  00d05	e9 2d 01 00 00	 jmp	 $LN611@inflate
$LN433@inflate:

; 983  :                 else {
; 984  :                     if (here.val == 16) {

  00d0a	0f b6 d2	 movzx	 edx, dl
  00d0d	75 5a		 jne	 SHORT $LN435@inflate

; 985  :                         NEEDBITS(here.bits + 2);

  00d0f	83 c2 02	 add	 edx, 2
  00d12	3b da		 cmp	 ebx, edx
  00d14	73 1d		 jae	 SHORT $LN196@inflate
$LL199@inflate:
  00d16	85 ff		 test	 edi, edi
  00d18	0f 84 cf fb ff
	ff		 je	 $LN963@inflate
  00d1e	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00d21	8b cb		 mov	 ecx, ebx
  00d23	d3 e0		 shl	 eax, cl
  00d25	ff cf		 dec	 edi
  00d27	03 e8		 add	 ebp, eax
  00d29	48 ff c6	 inc	 rsi
  00d2c	83 c3 08	 add	 ebx, 8
  00d2f	3b da		 cmp	 ebx, edx
  00d31	72 e3		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 986  :                         DROPBITS(here.bits);

  00d33	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR here$[rsp+1]

; 987  :                         if (state->have == 0) {

  00d38	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00d3f	2b d9		 sub	 ebx, ecx
  00d41	d3 ed		 shr	 ebp, cl
  00d43	85 c0		 test	 eax, eax
  00d45	0f 84 37 01 00
	00		 je	 $LN568@inflate

; 988  :                             strm->msg = (char *)"invalid bit length repeat";
; 989  :                             state->mode = BAD;
; 990  :                             break;
; 991  :                         }
; 992  :                         len = state->lens[state->have - 1];
; 993  :                         copy = 3 + BITS(2);

  00d4b	8b d5		 mov	 edx, ebp

; 994  :                         DROPBITS(2);

  00d4d	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00d50	83 e2 03	 and	 edx, 3
  00d53	c1 ed 02	 shr	 ebp, 2
  00d56	83 c2 03	 add	 edx, 3
  00d59	ff c8		 dec	 eax
  00d5b	45 0f b7 8c 45
	90 00 00 00	 movzx	 r9d, WORD PTR [r13+rax*2+144]

; 995  :                     }

  00d64	e9 8a 00 00 00	 jmp	 $LN236@inflate
$LN435@inflate:

; 996  :                     else if (here.val == 17) {

  00d69	66 41 83 f8 11	 cmp	 r8w, 17
  00d6e	75 40		 jne	 SHORT $LN226@inflate

; 997  :                         NEEDBITS(here.bits + 3);

  00d70	83 c2 03	 add	 edx, 3
  00d73	3b da		 cmp	 ebx, edx
  00d75	73 1d		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00d77	85 ff		 test	 edi, edi
  00d79	0f 84 6e fb ff
	ff		 je	 $LN963@inflate
  00d7f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00d82	8b cb		 mov	 ecx, ebx
  00d84	d3 e0		 shl	 eax, cl
  00d86	ff cf		 dec	 edi
  00d88	03 e8		 add	 ebp, eax
  00d8a	48 ff c6	 inc	 rsi
  00d8d	83 c3 08	 add	 ebx, 8
  00d90	3b da		 cmp	 ebx, edx
  00d92	72 e3		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 998  :                         DROPBITS(here.bits);

  00d94	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR here$[rsp+1]

; 999  :                         len = 0;
; 1000 :                         copy = 3 + BITS(3);
; 1001 :                         DROPBITS(3);

  00d99	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00d9e	d3 ed		 shr	 ebp, cl
  00da0	45 8b cf	 mov	 r9d, r15d
  00da3	8b d5		 mov	 edx, ebp
  00da5	83 e2 07	 and	 edx, 7
  00da8	83 c2 03	 add	 edx, 3
  00dab	c1 ed 03	 shr	 ebp, 3

; 1002 :                     }

  00dae	eb 3f		 jmp	 SHORT $LN997@inflate
$LN226@inflate:

; 1003 :                     else {
; 1004 :                         NEEDBITS(here.bits + 7);

  00db0	83 c2 07	 add	 edx, 7
  00db3	3b da		 cmp	 ebx, edx
  00db5	73 1d		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00db7	85 ff		 test	 edi, edi
  00db9	0f 84 2e fb ff
	ff		 je	 $LN963@inflate
  00dbf	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00dc2	8b cb		 mov	 ecx, ebx
  00dc4	d3 e0		 shl	 eax, cl
  00dc6	ff cf		 dec	 edi
  00dc8	03 e8		 add	 ebp, eax
  00dca	48 ff c6	 inc	 rsi
  00dcd	83 c3 08	 add	 ebx, 8
  00dd0	3b da		 cmp	 ebx, edx
  00dd2	72 e3		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 1005 :                         DROPBITS(here.bits);

  00dd4	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR here$[rsp+1]

; 1006 :                         len = 0;
; 1007 :                         copy = 11 + BITS(7);
; 1008 :                         DROPBITS(7);

  00dd9	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00dde	d3 ed		 shr	 ebp, cl
  00de0	45 0f b7 cf	 movzx	 r9d, r15w
  00de4	8b d5		 mov	 edx, ebp
  00de6	83 e2 7f	 and	 edx, 127		; 0000007fH
  00de9	83 c2 0b	 add	 edx, 11
  00dec	c1 ed 07	 shr	 ebp, 7
$LN997@inflate:

; 1009 :                     }
; 1010 :                     if (state->have + copy > state->nlen + state->ndist) {

  00def	2b c1		 sub	 eax, ecx
  00df1	03 d8		 add	 ebx, eax
$LN236@inflate:
  00df3	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00dfa	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00e01	03 ca		 add	 ecx, edx
  00e03	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00e07	3b c8		 cmp	 ecx, eax
  00e09	77 77		 ja	 SHORT $LN568@inflate
  00e0b	0f 1f 44 00 00	 npad	 5
$LL238@inflate:

; 1011 :                         strm->msg = (char *)"invalid bit length repeat";
; 1012 :                         state->mode = BAD;
; 1013 :                         break;
; 1014 :                     }
; 1015 :                     while (copy--)
; 1016 :                         state->lens[state->have++] = (unsigned short)len;

  00e10	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00e17	66 45 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r9w
  00e20	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e27	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00e2b	45 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], r8d
  00e32	83 c2 ff	 add	 edx, -1			; ffffffffH
  00e35	75 d9		 jne	 SHORT $LL238@inflate
$LN611@inflate:

; 971  :                 /* fallthrough */
; 972  :         case CODELENS:
; 973  :             while (state->have < state->nlen + state->ndist) {

  00e37	41 8b 8d 80 00
	00 00		 mov	 ecx, DWORD PTR [r13+128]
  00e3e	45 8b 55 7c	 mov	 r10d, DWORD PTR [r13+124]
  00e42	41 03 ca	 add	 ecx, r10d
  00e45	44 3b c1	 cmp	 r8d, ecx
  00e48	0f 82 12 fe ff
	ff		 jb	 $LL185@inflate

; 1210 :         case LIT:
; 1211 :             if (left == 0) goto inf_leave;

  00e4e	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
$LN186@inflate:

; 1017 :                 }
; 1018 :             }
; 1019 : 
; 1020 :             /* handle error breaks in while */
; 1021 :             if (state->mode == BAD) break;

  00e52	81 fa 51 3f 00
	00		 cmp	 edx, 16209		; 00003f51H
  00e58	0f 84 06 f9 ff
	ff		 je	 $LN930@inflate

; 1022 : 
; 1023 :             /* check for end-of-block code (better have one) */
; 1024 :             if (state->lens[256] == 0) {

  00e5e	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00e67	75 32		 jne	 SHORT $LN445@inflate

; 1025 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e69	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00e70	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1026 :                 state->mode = BAD;

  00e75	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1027 :                 break;

  00e7d	e9 e2 f8 ff ff	 jmp	 $LN930@inflate
$LN568@inflate:

; 651  :     in = have;
; 652  :     out = left;
; 653  :     ret = Z_OK;
; 654  :     for (;;)
; 655  :         switch (state->mode) {

  00e82	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e89	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00e8e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00e96	e9 c9 f8 ff ff	 jmp	 $LN930@inflate
$LN445@inflate:

; 1028 :             }
; 1029 : 
; 1030 :             /* build code tables -- note: do not change the lenbits or distbits
; 1031 :                values here (9 and 6) without reading the comments in inftrees.h
; 1032 :                concerning the ENOUGH constants, which depend on those values */
; 1033 :             state->next = state->codes;

  00e9b	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 1034 :             state->lencode = (const code FAR *)(state->next);
; 1035 :             state->lenbits = 9;

  00ea2	41 c7 45 70 09
	00 00 00	 mov	 DWORD PTR [r13+112], 9
  00eaa	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax

; 1036 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00eb1	4d 8d bd 10 03
	00 00		 lea	 r15, QWORD PTR [r13+784]
  00eb8	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00ebc	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00ec3	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  00ec7	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00ecc	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00ed3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ed8	45 8b c2	 mov	 r8d, r10d
  00edb	b9 01 00 00 00	 mov	 ecx, 1
  00ee0	e8 00 00 00 00	 call	 inflate_table
  00ee5	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax

; 1037 :                                 &(state->lenbits), state->work);
; 1038 :             if (ret) {

  00eec	85 c0		 test	 eax, eax
  00eee	74 19		 je	 SHORT $LN446@inflate

; 1039 :                 strm->msg = (char *)"invalid literal/lengths set";

  00ef0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00ef7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1040 :                 state->mode = BAD;

  00efc	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1041 :                 break;

  00f04	e9 5b f8 ff ff	 jmp	 $LN930@inflate
$LN446@inflate:

; 1042 :             }
; 1043 :             state->distcode = (const code FAR *)(state->next);

  00f09	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 1044 :             state->distbits = 6;

  00f10	49 8d 4d 74	 lea	 rcx, QWORD PTR [r13+116]

; 1045 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00f14	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  00f1b	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f22	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00f26	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00f2a	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00f30	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00f35	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f3a	b9 02 00 00 00	 mov	 ecx, 2
  00f3f	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00f47	49 03 d5	 add	 rdx, r13
  00f4a	e8 00 00 00 00	 call	 inflate_table
  00f4f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00f56	44 8b f8	 mov	 r15d, eax

; 1046 :                             &(state->next), &(state->distbits), state->work);
; 1047 :             if (ret) {

  00f59	85 c0		 test	 eax, eax
  00f5b	74 19		 je	 SHORT $LN447@inflate

; 1048 :                 strm->msg = (char *)"invalid distances set";

  00f5d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00f64	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1049 :                 state->mode = BAD;

  00f69	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1050 :                 break;

  00f71	e9 ee f7 ff ff	 jmp	 $LN930@inflate
$LN447@inflate:

; 1051 :             }
; 1052 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1053 :             state->mode = LEN_;
; 1054 :             if (flush == Z_TREES) goto inf_leave;

  00f76	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f7d	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  00f85	83 fa 06	 cmp	 edx, 6
  00f88	0f 84 e9 06 00
	00		 je	 $LN941@inflate
  00f8e	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  00f96	45 33 ff	 xor	 r15d, r15d
  00f99	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
$LN448@inflate:

; 1055 :                 /* fallthrough */
; 1056 :         case LEN_:
; 1057 :             state->mode = LEN;

  00f9e	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN450@inflate:

; 1058 :                 /* fallthrough */
; 1059 :         case LEN:
; 1060 :             if (have >= 6 && left >= 258) {

  00fa6	83 ff 06	 cmp	 edi, 6
  00fa9	72 77		 jb	 SHORT $LN451@inflate
  00fab	41 81 fa 02 01
	00 00		 cmp	 r10d, 258		; 00000102H
  00fb2	72 6e		 jb	 SHORT $LN451@inflate

; 1061 :                 RESTORE();

  00fb4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$1$[rsp]

; 1062 :                 inflate_fast(strm, out);

  00fb9	41 8b d0	 mov	 edx, r8d
  00fbc	49 89 4c 24 10	 mov	 QWORD PTR [r12+16], rcx
  00fc1	49 8b cc	 mov	 rcx, r12
  00fc4	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  00fc9	49 89 34 24	 mov	 QWORD PTR [r12], rsi
  00fcd	41 89 7c 24 08	 mov	 DWORD PTR [r12+8], edi
  00fd2	41 89 6d 48	 mov	 DWORD PTR [r13+72], ebp
  00fd6	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  00fda	e8 00 00 00 00	 call	 inflate_fast

; 1063 :                 LOAD();
; 1064 :                 if (state->mode == TYPE)

  00fdf	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  00fe7	4d 8b 4c 24 10	 mov	 r9, QWORD PTR [r12+16]
  00fec	45 8b 54 24 18	 mov	 r10d, DWORD PTR [r12+24]
  00ff1	49 8b 34 24	 mov	 rsi, QWORD PTR [r12]
  00ff5	41 8b 7c 24 08	 mov	 edi, DWORD PTR [r12+8]
  00ffa	41 8b 6d 48	 mov	 ebp, DWORD PTR [r13+72]
  00ffe	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  01002	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  01007	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  0100c	0f 85 5c f7 ff
	ff		 jne	 $LN8@inflate

; 1065 :                     state->back = -1;

  01012	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1066 :                 break;

  0101d	e9 4c f7 ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1067 :             }
; 1068 :             state->back = 0;
; 1069 :             for (;;) {
; 1070 :                 here = state->lencode[BITS(state->lenbits)];

  01022	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  01026	ba 01 00 00 00	 mov	 edx, 1
  0102b	4d 8b 55 60	 mov	 r10, QWORD PTR [r13+96]
  0102f	d3 e2		 shl	 edx, cl
  01031	ff ca		 dec	 edx
  01033	8b c5		 mov	 eax, ebp
  01035	8b ca		 mov	 ecx, edx
  01037	48 23 c8	 and	 rcx, rax
  0103a	45 89 bd e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r15d
  01041	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  01045	8b c8		 mov	 ecx, eax
  01047	c1 e9 08	 shr	 ecx, 8
  0104a	0f b6 c9	 movzx	 ecx, cl

; 1071 :                 if ((unsigned)(here.bits) <= bits) break;

  0104d	3b cb		 cmp	 ecx, ebx
  0104f	76 30		 jbe	 SHORT $LN570@inflate
$LL246@inflate:

; 1072 :                 PULLBYTE();

  01051	85 ff		 test	 edi, edi
  01053	0f 84 94 f8 ff
	ff		 je	 $LN963@inflate
  01059	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0105c	8b cb		 mov	 ecx, ebx
  0105e	d3 e0		 shl	 eax, cl
  01060	ff cf		 dec	 edi
  01062	03 e8		 add	 ebp, eax
  01064	48 ff c6	 inc	 rsi
  01067	8b cd		 mov	 ecx, ebp
  01069	83 c3 08	 add	 ebx, 8
  0106c	8b c2		 mov	 eax, edx
  0106e	48 23 c1	 and	 rax, rcx
  01071	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  01075	8b c8		 mov	 ecx, eax
  01077	c1 e9 08	 shr	 ecx, 8
  0107a	0f b6 c9	 movzx	 ecx, cl
  0107d	3b cb		 cmp	 ecx, ebx
  0107f	77 d0		 ja	 SHORT $LL246@inflate
$LN570@inflate:

; 1073 :             }
; 1074 :             if (here.op && (here.op & 0xf0) == 0) {

  01081	84 c0		 test	 al, al
  01083	0f 84 b4 00 00
	00		 je	 $LN263@inflate
  01089	a8 f0		 test	 al, 240			; 000000f0H
  0108b	0f 85 ac 00 00
	00		 jne	 $LN263@inflate

; 1075 :                 last = here;

  01091	8b c8		 mov	 ecx, eax
  01093	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax

; 1076 :                 for (;;) {
; 1077 :                     here = state->lencode[last.val +
; 1078 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1079 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01097	44 0f b6 74 24
	39		 movzx	 r14d, BYTE PTR last$[rsp+1]
  0109d	41 b8 01 00 00
	00		 mov	 r8d, 1
  010a3	c1 e9 08	 shr	 ecx, 8
  010a6	8b d0		 mov	 edx, eax
  010a8	44 0f b6 c9	 movzx	 r9d, cl
  010ac	0f b6 c8	 movzx	 ecx, al
  010af	41 03 c9	 add	 ecx, r9d
  010b2	c1 e8 10	 shr	 eax, 16
  010b5	41 d3 e0	 shl	 r8d, cl
  010b8	41 8b c9	 mov	 ecx, r9d
  010bb	41 ff c8	 dec	 r8d
  010be	44 23 c5	 and	 r8d, ebp
  010c1	41 d3 e8	 shr	 r8d, cl
  010c4	44 03 c0	 add	 r8d, eax
  010c7	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  010cb	8b c8		 mov	 ecx, eax
  010cd	c1 e9 08	 shr	 ecx, 8
  010d0	44 0f b6 c1	 movzx	 r8d, cl
  010d4	45 03 c1	 add	 r8d, r9d
  010d7	44 3b c3	 cmp	 r8d, ebx
  010da	76 52		 jbe	 SHORT $LN260@inflate
  010dc	44 0f b7 5c 24
	3a		 movzx	 r11d, WORD PTR last$[rsp+2]
$LL252@inflate:

; 1080 :                     PULLBYTE();

  010e2	85 ff		 test	 edi, edi
  010e4	0f 84 03 f8 ff
	ff		 je	 $LN963@inflate
  010ea	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  010ed	8b cb		 mov	 ecx, ebx
  010ef	d3 e0		 shl	 eax, cl
  010f1	41 b8 01 00 00
	00		 mov	 r8d, 1
  010f7	03 e8		 add	 ebp, eax
  010f9	0f b6 ca	 movzx	 ecx, dl
  010fc	41 03 ce	 add	 ecx, r14d
  010ff	ff cf		 dec	 edi
  01101	41 d3 e0	 shl	 r8d, cl
  01104	48 ff c6	 inc	 rsi
  01107	41 ff c8	 dec	 r8d
  0110a	41 8b ce	 mov	 ecx, r14d
  0110d	44 23 c5	 and	 r8d, ebp
  01110	83 c3 08	 add	 ebx, 8
  01113	41 d3 e8	 shr	 r8d, cl
  01116	45 03 c3	 add	 r8d, r11d
  01119	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  0111d	8b c8		 mov	 ecx, eax
  0111f	c1 e9 08	 shr	 ecx, 8
  01122	44 0f b6 c1	 movzx	 r8d, cl
  01126	45 03 c6	 add	 r8d, r14d
  01129	44 3b c3	 cmp	 r8d, ebx
  0112c	77 b4		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1081 :                 }
; 1082 :                 DROPBITS(last.bits);

  0112e	41 8b ce	 mov	 ecx, r14d
  01131	d3 ed		 shr	 ebp, cl
  01133	41 2b de	 sub	 ebx, r14d

; 1083 :                 state->back += last.bits;

  01136	41 89 8d e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], ecx
$LN263@inflate:

; 1084 :             }
; 1085 :             DROPBITS(here.bits);

  0113d	8b c8		 mov	 ecx, eax
  0113f	c1 e9 08	 shr	 ecx, 8
  01142	0f b6 c9	 movzx	 ecx, cl

; 1086 :             state->back += here.bits;

  01145	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0114c	2b d9		 sub	 ebx, ecx
  0114e	d3 ed		 shr	 ebp, cl

; 1087 :             state->length = (unsigned)here.val;

  01150	8b c8		 mov	 ecx, eax
  01152	c1 e9 10	 shr	 ecx, 16
  01155	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 1088 :             if ((int)(here.op) == 0) {

  01159	84 c0		 test	 al, al
  0115b	75 0d		 jne	 SHORT $LN458@inflate

; 1089 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1090 :                         "inflate:         literal '%c'\n" :
; 1091 :                         "inflate:         literal 0x%02x\n", here.val));
; 1092 :                 state->mode = LIT;

  0115d	41 c7 45 08 4d
	3f 00 00	 mov	 DWORD PTR [r13+8], 16205 ; 00003f4dH

; 1093 :                 break;

  01165	e9 fa f5 ff ff	 jmp	 $LN930@inflate
$LN458@inflate:

; 1094 :             }
; 1095 :             if (here.op & 32) {

  0116a	a8 20		 test	 al, 32			; 00000020H
  0116c	74 10		 je	 SHORT $LN459@inflate

; 1096 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1097 :                 state->back = -1;

  0116e	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1098 :                 state->mode = TYPE;
; 1099 :                 break;

  01179	e9 de f5 ff ff	 jmp	 $LN998@inflate
$LN459@inflate:

; 1100 :             }
; 1101 :             if (here.op & 64) {

  0117e	a8 40		 test	 al, 64			; 00000040H
  01180	74 19		 je	 SHORT $LN460@inflate

; 1102 :                 strm->msg = (char *)"invalid literal/length code";

  01182	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  01189	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1103 :                 state->mode = BAD;

  0118e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1104 :                 break;

  01196	e9 c9 f5 ff ff	 jmp	 $LN930@inflate
$LN460@inflate:

; 1105 :             }
; 1106 :             state->extra = (unsigned)(here.op) & 15;

  0119b	0f b6 c8	 movzx	 ecx, al
  0119e	83 e1 0f	 and	 ecx, 15

; 1107 :             state->mode = LENEXT;

  011a1	41 c7 45 08 49
	3f 00 00	 mov	 DWORD PTR [r13+8], 16201 ; 00003f49H
  011a9	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN461@inflate:

; 1108 :                 /* fallthrough */
; 1109 :         case LENEXT:
; 1110 :             if (state->extra) {

  011ad	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  011b1	85 d2		 test	 edx, edx
  011b3	74 44		 je	 SHORT $LN754@inflate

; 1111 :                 NEEDBITS(state->extra);

  011b5	3b da		 cmp	 ebx, edx
  011b7	73 24		 jae	 SHORT $LN264@inflate
  011b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL267@inflate:
  011c0	85 ff		 test	 edi, edi
  011c2	0f 84 25 f7 ff
	ff		 je	 $LN963@inflate
  011c8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  011cb	8b cb		 mov	 ecx, ebx
  011cd	d3 e0		 shl	 eax, cl
  011cf	ff cf		 dec	 edi
  011d1	03 e8		 add	 ebp, eax
  011d3	48 ff c6	 inc	 rsi
  011d6	83 c3 08	 add	 ebx, 8
  011d9	3b da		 cmp	 ebx, edx
  011db	72 e3		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1112 :                 state->length += BITS(state->extra);

  011dd	8b ca		 mov	 ecx, edx
  011df	b8 01 00 00 00	 mov	 eax, 1
  011e4	d3 e0		 shl	 eax, cl

; 1113 :                 DROPBITS(state->extra);

  011e6	2b da		 sub	 ebx, edx
  011e8	ff c8		 dec	 eax
  011ea	23 c5		 and	 eax, ebp
  011ec	d3 ed		 shr	 ebp, cl
  011ee	41 01 45 50	 add	 DWORD PTR [r13+80], eax

; 1114 :                 state->back += state->extra;

  011f2	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN754@inflate:

; 1115 :             }
; 1116 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1117 :             state->was = state->length;

  011f9	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  011fd	41 89 85 e8 1b
	00 00		 mov	 DWORD PTR [r13+7144], eax

; 1118 :             state->mode = DIST;

  01204	41 c7 45 08 4a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16202 ; 00003f4aH
$LN464@inflate:

; 1119 :                 /* fallthrough */
; 1120 :         case DIST:
; 1121 :             for (;;) {
; 1122 :                 here = state->distcode[BITS(state->distbits)];

  0120c	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  01210	ba 01 00 00 00	 mov	 edx, 1
  01215	4d 8b 55 68	 mov	 r10, QWORD PTR [r13+104]
  01219	d3 e2		 shl	 edx, cl
  0121b	ff ca		 dec	 edx
  0121d	8b c5		 mov	 eax, ebp
  0121f	8b ca		 mov	 ecx, edx
  01221	48 23 c8	 and	 rcx, rax
  01224	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  01228	8b c8		 mov	 ecx, eax
  0122a	c1 e9 08	 shr	 ecx, 8
  0122d	0f b6 c9	 movzx	 ecx, cl

; 1123 :                 if ((unsigned)(here.bits) <= bits) break;

  01230	3b cb		 cmp	 ecx, ebx
  01232	76 30		 jbe	 SHORT $LN575@inflate
$LL275@inflate:

; 1124 :                 PULLBYTE();

  01234	85 ff		 test	 edi, edi
  01236	0f 84 b1 f6 ff
	ff		 je	 $LN963@inflate
  0123c	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0123f	8b cb		 mov	 ecx, ebx
  01241	d3 e0		 shl	 eax, cl
  01243	ff cf		 dec	 edi
  01245	03 e8		 add	 ebp, eax
  01247	48 ff c6	 inc	 rsi
  0124a	8b cd		 mov	 ecx, ebp
  0124c	83 c3 08	 add	 ebx, 8
  0124f	8b c2		 mov	 eax, edx
  01251	48 23 c1	 and	 rax, rcx
  01254	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  01258	8b c8		 mov	 ecx, eax
  0125a	c1 e9 08	 shr	 ecx, 8
  0125d	0f b6 c9	 movzx	 ecx, cl
  01260	3b cb		 cmp	 ecx, ebx
  01262	77 d0		 ja	 SHORT $LL275@inflate
$LN575@inflate:

; 1125 :             }
; 1126 :             if ((here.op & 0xf0) == 0) {

  01264	a8 f0		 test	 al, 240			; 000000f0H
  01266	0f 85 af 00 00
	00		 jne	 $LN292@inflate

; 1127 :                 last = here;

  0126c	8b c8		 mov	 ecx, eax
  0126e	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax

; 1128 :                 for (;;) {
; 1129 :                     here = state->distcode[last.val +
; 1130 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1131 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01272	44 0f b6 74 24
	39		 movzx	 r14d, BYTE PTR last$[rsp+1]
  01278	41 b8 01 00 00
	00		 mov	 r8d, 1
  0127e	c1 e9 08	 shr	 ecx, 8
  01281	8b d0		 mov	 edx, eax
  01283	44 0f b6 c9	 movzx	 r9d, cl
  01287	0f b6 c8	 movzx	 ecx, al
  0128a	41 03 c9	 add	 ecx, r9d
  0128d	c1 e8 10	 shr	 eax, 16
  01290	41 d3 e0	 shl	 r8d, cl
  01293	41 8b c9	 mov	 ecx, r9d
  01296	41 ff c8	 dec	 r8d
  01299	44 23 c5	 and	 r8d, ebp
  0129c	41 d3 e8	 shr	 r8d, cl
  0129f	44 03 c0	 add	 r8d, eax
  012a2	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  012a6	8b c8		 mov	 ecx, eax
  012a8	c1 e9 08	 shr	 ecx, 8
  012ab	44 0f b6 c1	 movzx	 r8d, cl
  012af	45 03 c1	 add	 r8d, r9d
  012b2	44 3b c3	 cmp	 r8d, ebx
  012b5	76 55		 jbe	 SHORT $LN289@inflate
  012b7	44 0f b7 5c 24
	3a		 movzx	 r11d, WORD PTR last$[rsp+2]
  012bd	0f 1f 00	 npad	 3
$LL281@inflate:

; 1132 :                     PULLBYTE();

  012c0	85 ff		 test	 edi, edi
  012c2	0f 84 25 f6 ff
	ff		 je	 $LN963@inflate
  012c8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  012cb	8b cb		 mov	 ecx, ebx
  012cd	d3 e0		 shl	 eax, cl
  012cf	41 b8 01 00 00
	00		 mov	 r8d, 1
  012d5	03 e8		 add	 ebp, eax
  012d7	0f b6 ca	 movzx	 ecx, dl
  012da	41 03 ce	 add	 ecx, r14d
  012dd	ff cf		 dec	 edi
  012df	41 d3 e0	 shl	 r8d, cl
  012e2	48 ff c6	 inc	 rsi
  012e5	41 ff c8	 dec	 r8d
  012e8	41 8b ce	 mov	 ecx, r14d
  012eb	44 23 c5	 and	 r8d, ebp
  012ee	83 c3 08	 add	 ebx, 8
  012f1	41 d3 e8	 shr	 r8d, cl
  012f4	45 03 c3	 add	 r8d, r11d
  012f7	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  012fb	8b c8		 mov	 ecx, eax
  012fd	c1 e9 08	 shr	 ecx, 8
  01300	44 0f b6 c1	 movzx	 r8d, cl
  01304	45 03 c6	 add	 r8d, r14d
  01307	44 3b c3	 cmp	 r8d, ebx
  0130a	77 b4		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1133 :                 }
; 1134 :                 DROPBITS(last.bits);

  0130c	41 8b ce	 mov	 ecx, r14d
  0130f	41 2b de	 sub	 ebx, r14d
  01312	d3 ed		 shr	 ebp, cl

; 1135 :                 state->back += last.bits;

  01314	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
$LN292@inflate:

; 1136 :             }
; 1137 :             DROPBITS(here.bits);
; 1138 :             state->back += here.bits;
; 1139 :             if (here.op & 64) {

  0131b	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  01320	8b c8		 mov	 ecx, eax
  01322	c1 e9 08	 shr	 ecx, 8
  01325	0f b6 c9	 movzx	 ecx, cl
  01328	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0132f	2b d9		 sub	 ebx, ecx
  01331	d3 ed		 shr	 ebp, cl
  01333	a8 40		 test	 al, 64			; 00000040H
  01335	74 19		 je	 SHORT $LN470@inflate

; 1140 :                 strm->msg = (char *)"invalid distance code";

  01337	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  0133e	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1141 :                 state->mode = BAD;

  01343	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1142 :                 break;

  0134b	e9 19 f4 ff ff	 jmp	 $LN996@inflate
$LN470@inflate:
  01350	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]

; 1143 :             }
; 1144 :             state->offset = (unsigned)here.val;

  01358	8b c8		 mov	 ecx, eax
  0135a	c1 e9 10	 shr	 ecx, 16
  0135d	41 89 4d 54	 mov	 DWORD PTR [r13+84], ecx

; 1145 :             state->extra = (unsigned)(here.op) & 15;

  01361	0f b6 c8	 movzx	 ecx, al
  01364	83 e1 0f	 and	 ecx, 15

; 1146 :             state->mode = DISTEXT;

  01367	41 c7 45 08 4b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16203 ; 00003f4bH
  0136f	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN471@inflate:

; 1147 :                 /* fallthrough */
; 1148 :         case DISTEXT:
; 1149 :             if (state->extra) {

  01373	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  01377	85 d2		 test	 edx, edx
  01379	74 3e		 je	 SHORT $LN756@inflate

; 1150 :                 NEEDBITS(state->extra);

  0137b	3b da		 cmp	 ebx, edx
  0137d	73 1e		 jae	 SHORT $LN293@inflate
  0137f	90		 npad	 1
$LL296@inflate:
  01380	85 ff		 test	 edi, edi
  01382	0f 84 65 f5 ff
	ff		 je	 $LN963@inflate
  01388	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0138b	8b cb		 mov	 ecx, ebx
  0138d	d3 e0		 shl	 eax, cl
  0138f	ff cf		 dec	 edi
  01391	03 e8		 add	 ebp, eax
  01393	48 ff c6	 inc	 rsi
  01396	83 c3 08	 add	 ebx, 8
  01399	3b da		 cmp	 ebx, edx
  0139b	72 e3		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1151 :                 state->offset += BITS(state->extra);

  0139d	8b ca		 mov	 ecx, edx
  0139f	b8 01 00 00 00	 mov	 eax, 1
  013a4	d3 e0		 shl	 eax, cl

; 1152 :                 DROPBITS(state->extra);

  013a6	2b da		 sub	 ebx, edx
  013a8	ff c8		 dec	 eax
  013aa	23 c5		 and	 eax, ebp
  013ac	d3 ed		 shr	 ebp, cl
  013ae	41 01 45 54	 add	 DWORD PTR [r13+84], eax

; 1153 :                 state->back += state->extra;

  013b2	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN756@inflate:

; 1154 :             }
; 1155 : #ifdef INFLATE_STRICT
; 1156 :             if (state->offset > state->dmax) {
; 1157 :                 strm->msg = (char *)"invalid distance too far back";
; 1158 :                 state->mode = BAD;
; 1159 :                 break;
; 1160 :             }
; 1161 : #endif
; 1162 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1163 :             state->mode = MATCH;

  013b9	41 c7 45 08 4c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1164 :                 /* fallthrough */
; 1165 :         case MATCH:
; 1166 :             if (left == 0) goto inf_leave;

  013c1	45 85 d2	 test	 r10d, r10d
  013c4	0f 84 23 f5 ff
	ff		 je	 $LN963@inflate

; 1167 :             copy = out - left;
; 1168 :             if (state->offset > copy) {         /* copy from window */

  013ca	41 8b 45 54	 mov	 eax, DWORD PTR [r13+84]
  013ce	41 8b c8	 mov	 ecx, r8d
  013d1	41 2b ca	 sub	 ecx, r10d
  013d4	3b c1		 cmp	 eax, ecx
  013d6	76 51		 jbe	 SHORT $LN476@inflate

; 1169 :                 copy = state->offset - copy;

  013d8	2b c1		 sub	 eax, ecx

; 1170 :                 if (copy > state->whave) {

  013da	41 3b 45 38	 cmp	 eax, DWORD PTR [r13+56]
  013de	76 23		 jbe	 SHORT $LN479@inflate

; 1171 :                     if (state->sane) {

  013e0	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  013e8	74 19		 je	 SHORT $LN479@inflate

; 1172 :                         strm->msg = (char *)"invalid distance too far back";

  013ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  013f1	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1173 :                         state->mode = BAD;

  013f6	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1174 :                         break;

  013fe	e9 66 f3 ff ff	 jmp	 $LN996@inflate
$LN479@inflate:

; 1175 :                     }
; 1176 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1177 :                     Trace((stderr, "inflate.c too far\n"));
; 1178 :                     copy -= state->whave;
; 1179 :                     if (copy > state->length) copy = state->length;
; 1180 :                     if (copy > left) copy = left;
; 1181 :                     left -= copy;
; 1182 :                     state->length -= copy;
; 1183 :                     do {
; 1184 :                         *put++ = 0;
; 1185 :                     } while (--copy);
; 1186 :                     if (state->length == 0) state->mode = LEN;
; 1187 :                     break;
; 1188 : #endif
; 1189 :                 }
; 1190 :                 if (copy > state->wnext) {

  01403	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  01407	3b c1		 cmp	 eax, ecx
  01409	76 06		 jbe	 SHORT $LN480@inflate

; 1191 :                     copy -= state->wnext;

  0140b	2b c1		 sub	 eax, ecx

; 1192 :                     from = state->window + (state->wsize - copy);

  0140d	41 8b 4d 34	 mov	 ecx, DWORD PTR [r13+52]
$LN480@inflate:

; 1193 :                 }
; 1194 :                 else
; 1195 :                     from = state->window + (state->wnext - copy);
; 1196 :                 if (copy > state->length) copy = state->length;

  01411	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01415	2b c8		 sub	 ecx, eax
  01417	8b d1		 mov	 edx, ecx

; 1197 :             }

  01419	45 8b c8	 mov	 r9d, r8d
  0141c	49 03 55 40	 add	 rdx, QWORD PTR [r13+64]
  01420	41 3b c0	 cmp	 eax, r8d
  01423	44 0f 46 c8	 cmovbe	 r9d, eax
  01427	eb 0f		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1198 :             else {                              /* copy from output */
; 1199 :                 from = put - state->offset;

  01429	48 8b 54 24 40	 mov	 rdx, QWORD PTR put$1$[rsp]

; 1200 :                 copy = state->length;

  0142e	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01432	48 2b d0	 sub	 rdx, rax
  01435	45 8b c8	 mov	 r9d, r8d
$LN477@inflate:

; 1201 :             }
; 1202 :             if (copy > left) copy = left;
; 1203 :             left -= copy;

  01438	45 3b ca	 cmp	 r9d, r10d
  0143b	41 8b ca	 mov	 ecx, r10d
  0143e	41 0f 46 c9	 cmovbe	 ecx, r9d

; 1204 :             state->length -= copy;

  01442	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  01447	44 2b d1	 sub	 r10d, ecx
  0144a	44 2b c1	 sub	 r8d, ecx
  0144d	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  01452	49 2b d1	 sub	 rdx, r9
  01455	45 89 45 50	 mov	 DWORD PTR [r13+80], r8d
  01459	0f 1f 80 00 00
	00 00		 npad	 7
$LL306@inflate:

; 1205 :             do {
; 1206 :                 *put++ = *from++;

  01460	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  01465	41 88 01	 mov	 BYTE PTR [r9], al
  01468	49 ff c1	 inc	 r9

; 1207 :             } while (--copy);

  0146b	83 c1 ff	 add	 ecx, -1			; ffffffffH
  0146e	75 f0		 jne	 SHORT $LL306@inflate

; 1208 :             if (state->length == 0) state->mode = LEN;

  01470	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  01475	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  01479	0f 85 ef f2 ff
	ff		 jne	 $LN8@inflate
  0147f	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1209 :             break;

  01487	e9 e2 f2 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1210 :         case LIT:
; 1211 :             if (left == 0) goto inf_leave;

  0148c	45 85 d2	 test	 r10d, r10d
  0148f	0f 84 58 f4 ff
	ff		 je	 $LN963@inflate

; 1212 :             *put++ = (unsigned char)(state->length);

  01495	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  0149a	41 88 01	 mov	 BYTE PTR [r9], al
  0149d	49 ff c1	 inc	 r9

; 1213 :             --left;

  014a0	41 ff ca	 dec	 r10d
  014a3	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  014a8	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d

; 1214 :             state->mode = LEN;

  014ad	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1215 :             break;

  014b5	e9 b4 f2 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1216 :         case CHECK:
; 1217 :             if (state->wrap) {

  014ba	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  014bf	0f 84 de 00 00
	00		 je	 $LN966@inflate

; 1218 :                 NEEDBITS(32);

  014c5	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014c8	73 24		 jae	 SHORT $LN307@inflate
  014ca	66 0f 1f 44 00
	00		 npad	 6
$LL310@inflate:
  014d0	85 ff		 test	 edi, edi
  014d2	0f 84 15 f4 ff
	ff		 je	 $LN963@inflate
  014d8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  014db	8b cb		 mov	 ecx, ebx
  014dd	d3 e0		 shl	 eax, cl
  014df	ff cf		 dec	 edi
  014e1	03 e8		 add	 ebp, eax
  014e3	48 ff c6	 inc	 rsi
  014e6	83 c3 08	 add	 ebx, 8
  014e9	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014ec	72 e2		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1219 :                 out -= left;

  014ee	45 2b c2	 sub	 r8d, r10d

; 1220 :                 strm->total_out += out;

  014f1	45 01 44 24 1c	 add	 DWORD PTR [r12+28], r8d

; 1221 :                 state->total += out;

  014f6	45 01 45 24	 add	 DWORD PTR [r13+36], r8d

; 1222 :                 if ((state->wrap & 4) && out)

  014fa	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
  014fe	a8 04		 test	 al, 4
  01500	74 37		 je	 SHORT $LN490@inflate
  01502	45 85 c0	 test	 r8d, r8d
  01505	74 32		 je	 SHORT $LN490@inflate

; 1223 :                     strm->adler = state->check =

  01507	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0150b	49 8b d1	 mov	 rdx, r9
  0150e	41 8b c0	 mov	 eax, r8d
  01511	48 2b d0	 sub	 rdx, rax
  01514	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01519	74 07		 je	 SHORT $LN512@inflate
  0151b	e8 00 00 00 00	 call	 crc32
  01520	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01522	e8 00 00 00 00	 call	 adler32
$LN513@inflate:
  01527	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  0152c	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01530	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  01535	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
$LN490@inflate:

; 1224 :                         UPDATE_CHECK(state->check, put - out, out);
; 1225 :                 out = left;

  01539	44 89 94 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r10d
  01541	45 8b f2	 mov	 r14d, r10d

; 1226 :                 if ((state->wrap & 4) && (

  01544	a8 04		 test	 al, 4
  01546	74 4b		 je	 SHORT $LN317@inflate
  01548	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  0154d	8b cd		 mov	 ecx, ebp
  0154f	75 23		 jne	 SHORT $LN515@inflate
  01551	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01557	8b c5		 mov	 eax, ebp
  01559	c1 e0 10	 shl	 eax, 16
  0155c	03 c8		 add	 ecx, eax
  0155e	8b c5		 mov	 eax, ebp
  01560	c1 e8 08	 shr	 eax, 8
  01563	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01568	c1 e1 08	 shl	 ecx, 8
  0156b	03 c8		 add	 ecx, eax
  0156d	8b c5		 mov	 eax, ebp
  0156f	c1 e8 18	 shr	 eax, 24
  01572	03 c8		 add	 ecx, eax
$LN515@inflate:
  01574	41 3b 4d 20	 cmp	 ecx, DWORD PTR [r13+32]
  01578	74 19		 je	 SHORT $LN317@inflate

; 1227 : #ifdef GUNZIP
; 1228 :                      state->flags ? hold :
; 1229 : #endif
; 1230 :                      ZSWAP32(hold)) != state->check) {
; 1231 :                     strm->msg = (char *)"incorrect data check";

  0157a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  01581	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1232 :                     state->mode = BAD;

  01586	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1233 :                     break;

  0158e	e9 d6 f1 ff ff	 jmp	 $LN996@inflate
$LN317@inflate:

; 1234 :                 }
; 1235 :                 INITBITS();

  01593	41 8b ef	 mov	 ebp, r15d

; 1236 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1237 :             }
; 1238 : #ifdef GUNZIP
; 1239 :             state->mode = LENGTH;

  01596	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  0159e	41 8b df	 mov	 ebx, r15d
  015a1	eb 1a		 jmp	 SHORT $LN492@inflate
$LN966@inflate:

; 1216 :         case CHECK:
; 1217 :             if (state->wrap) {

  015a3	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR out$1$[rsp]

; 1236 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1237 :             }
; 1238 : #ifdef GUNZIP
; 1239 :             state->mode = LENGTH;

  015ab	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015b3	eb 08		 jmp	 SHORT $LN492@inflate
$LN965@inflate:

; 651  :     in = have;
; 652  :     out = left;
; 653  :     ret = Z_OK;
; 654  :     for (;;)
; 655  :         switch (state->mode) {

  015b5	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR out$1$[rsp]
$LN492@inflate:

; 1240 :                 /* fallthrough */
; 1241 :         case LENGTH:
; 1242 :             if (state->wrap && state->flags) {

  015bd	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  015c1	85 d2		 test	 edx, edx
  015c3	74 79		 je	 SHORT $LN327@inflate
  015c5	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  015ca	74 72		 je	 SHORT $LN327@inflate

; 1243 :                 NEEDBITS(32);

  015cc	83 fb 20	 cmp	 ebx, 32			; 00000020H
  015cf	73 1e		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  015d1	85 ff		 test	 edi, edi
  015d3	0f 84 1c f3 ff
	ff		 je	 $LN967@inflate
  015d9	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  015dc	8b cb		 mov	 ecx, ebx
  015de	d3 e0		 shl	 eax, cl
  015e0	ff cf		 dec	 edi
  015e2	03 e8		 add	 ebp, eax
  015e4	48 ff c6	 inc	 rsi
  015e7	83 c3 08	 add	 ebx, 8
  015ea	83 fb 20	 cmp	 ebx, 32			; 00000020H
  015ed	72 e2		 jb	 SHORT $LL321@inflate
$LN318@inflate:

; 1244 :                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {

  015ef	f6 c2 04	 test	 dl, 4
  015f2	74 44		 je	 SHORT $LN328@inflate
  015f4	41 3b 6d 24	 cmp	 ebp, DWORD PTR [r13+36]
  015f8	74 3e		 je	 SHORT $LN328@inflate

; 1245 :                     strm->msg = (char *)"incorrect length check";

  015fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  01601	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1246 :                     state->mode = BAD;

  01606	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  0160e	e9 56 f1 ff ff	 jmp	 $LN996@inflate
$LN587@inflate:

; 851  :                 RESTORE();

  01613	4d 89 4c 24 10	 mov	 QWORD PTR [r12+16], r9

; 852  :                 return Z_NEED_DICT;

  01618	b8 02 00 00 00	 mov	 eax, 2
  0161d	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  01622	49 89 34 24	 mov	 QWORD PTR [r12], rsi
  01626	41 89 7c 24 08	 mov	 DWORD PTR [r12+8], edi
  0162b	41 89 6d 48	 mov	 DWORD PTR [r13+72], ebp
  0162f	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  01633	e9 26 01 00 00	 jmp	 $LN1@inflate
$LN328@inflate:

; 1247 :                     break;
; 1248 :                 }
; 1249 :                 INITBITS();

  01638	41 8b ef	 mov	 ebp, r15d
  0163b	41 8b df	 mov	 ebx, r15d
$LN327@inflate:

; 1250 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1251 :             }
; 1252 : #endif
; 1253 :             state->mode = DONE;

  0163e	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H

; 1254 :                 /* fallthrough */
; 1255 :         case DONE:
; 1256 :             ret = Z_STREAM_END;

  01646	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1257 :             goto inf_leave;

  0164c	e9 ac f2 ff ff	 jmp	 $LN1000@inflate
$LN964@inflate:

; 651  :     in = have;
; 652  :     out = left;
; 653  :     ret = Z_OK;
; 654  :     for (;;)
; 655  :         switch (state->mode) {

  01651	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR out$1$[rsp]

; 1254 :                 /* fallthrough */
; 1255 :         case DONE:
; 1256 :             ret = Z_STREAM_END;

  01659	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1257 :             goto inf_leave;

  0165f	e9 99 f2 ff ff	 jmp	 $LN1000@inflate
$LN497@inflate:
  01664	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR out$1$[rsp]

; 1258 :         case BAD:
; 1259 :             ret = Z_DATA_ERROR;

  0166c	41 bf fd ff ff
	ff		 mov	 r15d, -3
  01672	e9 86 f2 ff ff	 jmp	 $LN1000@inflate
$LN941@inflate:

; 1051 :             }
; 1052 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1053 :             state->mode = LEN_;
; 1054 :             if (flush == Z_TREES) goto inf_leave;

  01677	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR out$1$[rsp]
  0167f	e9 80 f2 ff ff	 jmp	 $inf_leave$1003
$LN504@inflate:

; 1281 :             return Z_MEM_ERROR;
; 1282 :         }
; 1283 :     in -= strm->avail_in;
; 1284 :     out -= strm->avail_out;

  01684	45 2b 74 24 18	 sub	 r14d, DWORD PTR [r12+24]
  01689	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  0168e	45 2b 54 24 08	 sub	 r10d, DWORD PTR [r12+8]

; 1285 :     strm->total_in += in;

  01693	45 01 54 24 0c	 add	 DWORD PTR [r12+12], r10d

; 1286 :     strm->total_out += out;

  01698	45 01 74 24 1c	 add	 DWORD PTR [r12+28], r14d

; 1287 :     state->total += out;

  0169d	45 01 75 24	 add	 DWORD PTR [r13+36], r14d

; 1288 :     if ((state->wrap & 4) && out)

  016a1	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  016a6	44 89 54 24 3c	 mov	 DWORD PTR in$1$[rsp], r10d
  016ab	74 38		 je	 SHORT $LN505@inflate
  016ad	45 85 f6	 test	 r14d, r14d
  016b0	74 33		 je	 SHORT $LN505@inflate

; 1289 :         strm->adler = state->check =

  016b2	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  016b7	45 8b c6	 mov	 r8d, r14d
  016ba	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  016be	41 8b c6	 mov	 eax, r14d
  016c1	48 2b d0	 sub	 rdx, rax
  016c4	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  016c9	74 07		 je	 SHORT $LN516@inflate
  016cb	e8 00 00 00 00	 call	 crc32
  016d0	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  016d2	e8 00 00 00 00	 call	 adler32
$LN517@inflate:
  016d7	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  016dc	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  016e0	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN505@inflate:

; 1290 :             UPDATE_CHECK(state->check, strm->next_out - out, out);
; 1291 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  016e5	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  016e9	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  016ef	74 10		 je	 SHORT $LN518@inflate
  016f1	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  016f7	74 08		 je	 SHORT $LN518@inflate
  016f9	45 33 c9	 xor	 r9d, r9d
  016fc	45 8b c1	 mov	 r8d, r9d
  016ff	eb 09		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01701	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01707	45 33 c9	 xor	 r9d, r9d
$LN519@inflate:
  0170a	41 8b 45 0c	 mov	 eax, DWORD PTR [r13+12]
  0170e	f7 d8		 neg	 eax
  01710	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  01715	1b c9		 sbb	 ecx, ecx
  01717	83 e1 40	 and	 ecx, 64			; 00000040H
  0171a	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01720	44 0f 44 c8	 cmove	 r9d, eax
  01724	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  01728	44 03 c8	 add	 r9d, eax
  0172b	45 03 4d 4c	 add	 r9d, DWORD PTR [r13+76]
  0172f	45 89 4c 24 48	 mov	 DWORD PTR [r12+72], r9d

; 1292 :                       (state->mode == TYPE ? 128 : 0) +
; 1293 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1294 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01734	45 85 d2	 test	 r10d, r10d
  01737	75 05		 jne	 SHORT $LN508@inflate
  01739	45 85 f6	 test	 r14d, r14d
  0173c	74 0a		 je	 SHORT $LN507@inflate
$LN508@inflate:
  0173e	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  01746	75 0c		 jne	 SHORT $LN506@inflate
$LN507@inflate:
  01748	45 85 ff	 test	 r15d, r15d
  0174b	b8 fb ff ff ff	 mov	 eax, -5
  01750	44 0f 44 f8	 cmove	 r15d, eax
$LN506@inflate:

; 1295 :         ret = Z_BUF_ERROR;
; 1296 :     return ret;

  01754	41 8b c7	 mov	 eax, r15d
  01757	eb 05		 jmp	 SHORT $LN1@inflate
$LN333@inflate:

; 645  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 646  :         return Z_STREAM_ERROR;

  01759	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflate:

; 1297 : }

  0175e	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  01766	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0176a	41 5f		 pop	 r15
  0176c	41 5e		 pop	 r14
  0176e	41 5d		 pop	 r13
  01770	41 5c		 pop	 r12
  01772	5f		 pop	 rdi
  01773	5e		 pop	 rsi
  01774	5d		 pop	 rbp
  01775	c3		 ret	 0
  01776	66 90		 npad	 2
$LN845@inflate:
  01778	00 00 00 00	 DD	 $LN335@inflate
  0177c	00 00 00 00	 DD	 $LN32@inflate
  01780	00 00 00 00	 DD	 $LN46@inflate
  01784	00 00 00 00	 DD	 $LN60@inflate
  01788	00 00 00 00	 DD	 $LN361@inflate
  0178c	00 00 00 00	 DD	 $LN368@inflate
  01790	00 00 00 00	 DD	 $LN375@inflate
  01794	00 00 00 00	 DD	 $LN384@inflate
  01798	00 00 00 00	 DD	 $LN393@inflate
  0179c	00 00 00 00	 DD	 $LN105@inflate
  017a0	00 00 00 00	 DD	 $LN400@inflate
  017a4	00 00 00 00	 DD	 $LN402@inflate
  017a8	00 00 00 00	 DD	 $LN403@inflate
  017ac	00 00 00 00	 DD	 $LN141@inflate
  017b0	00 00 00 00	 DD	 $LN416@inflate
  017b4	00 00 00 00	 DD	 $LN418@inflate
  017b8	00 00 00 00	 DD	 $LN155@inflate
  017bc	00 00 00 00	 DD	 $LN533@inflate
  017c0	00 00 00 00	 DD	 $LN536@inflate
  017c4	00 00 00 00	 DD	 $LN448@inflate
  017c8	00 00 00 00	 DD	 $LN450@inflate
  017cc	00 00 00 00	 DD	 $LN461@inflate
  017d0	00 00 00 00	 DD	 $LN464@inflate
  017d4	00 00 00 00	 DD	 $LN471@inflate
  017d8	00 00 00 00	 DD	 $LN474@inflate
  017dc	00 00 00 00	 DD	 $LN485@inflate
  017e0	00 00 00 00	 DD	 $LN487@inflate
  017e4	00 00 00 00	 DD	 $LN965@inflate
  017e8	00 00 00 00	 DD	 $LN964@inflate
  017ec	00 00 00 00	 DD	 $LN497@inflate
  017f0	00 00 00 00	 DD	 $LN498@inflate
  017f4	00 00 00 00	 DD	 $LN333@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1300 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1301 :     struct inflate_state FAR *state;
; 1302 :     if (inflateStateCheck(strm))

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@inflateEnd

; 1303 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1310 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@inflateEnd:

; 1304 :     state = (struct inflate_state FAR *)strm->state;

  0001d	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]

; 1305 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00021	48 8b 42 40	 mov	 rax, QWORD PTR [rdx+64]
  00025	48 85 c0	 test	 rax, rax
  00028	74 0e		 je	 SHORT $LN3@inflateEnd
  0002a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	ff 53 38	 call	 QWORD PTR [rbx+56]
  00034	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
$LN3@inflateEnd:

; 1306 :     ZFREE(strm, strm->state);

  00038	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0003c	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1307 :     strm->state = Z_NULL;
; 1308 :     Tracev((stderr, "inflate: end\n"));
; 1309 :     return Z_OK;

  0003f	33 c0		 xor	 eax, eax
  00041	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1310 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
strm$ = 8
inflateStateCheck PROC					; COMDAT

; 107  :     struct inflate_state FAR *state;
; 108  :     if (strm == Z_NULL ||
; 109  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2c		 je	 SHORT $LN3@inflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 25		 je	 SHORT $LN3@inflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 1e		 je	 SHORT $LN3@inflateSta

; 111  :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 112  :     if (state == Z_NULL || state->strm != strm ||
; 113  :         state->mode < HEAD || state->mode > SYNC)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 15		 je	 SHORT $LN3@inflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 10		 jne	 SHORT $LN3@inflateSta
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00029	83 f8 1f	 cmp	 eax, 31
  0002c	77 03		 ja	 SHORT $LN3@inflateSta

; 114  :         return 1;
; 115  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 116  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 110  :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 116  : }

  00036	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 48
inflateResetKeep PROC					; COMDAT

; 119  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b d1	 mov	 rdx, rcx

; 120  :     struct inflate_state FAR *state;
; 121  : 
; 122  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateRes
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 141  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateRes:

; 123  :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 124  :     strm->total_in = strm->total_out = state->total = 0;

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
  00025	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00029	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d

; 125  :     strm->msg = Z_NULL;

  0002d	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8

; 126  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $LN3@inflateRes

; 127  :         strm->adler = state->wrap & 1;

  00038	83 e0 01	 and	 eax, 1
  0003b	89 42 4c	 mov	 DWORD PTR [rdx+76], eax
$LN3@inflateRes:

; 128  :     state->mode = HEAD;
; 129  :     state->last = 0;
; 130  :     state->havedict = 0;
; 131  :     state->flags = -1;
; 132  :     state->dmax = 32768U;
; 133  :     state->head = Z_NULL;
; 134  :     state->hold = 0;
; 135  :     state->bits = 0;
; 136  :     state->lencode = state->distcode = state->next = state->codes;

  0003e	48 8d 81 50 05
	00 00		 lea	 rax, QWORD PTR [rcx+1360]
  00045	48 c7 41 08 34
	3f 00 00	 mov	 QWORD PTR [rcx+8], 16180 ; 00003f34H
  0004d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00054	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00058	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 137  :     state->sane = 1;
; 138  :     state->back = -1;
; 139  :     Tracev((stderr, "inflate: reset\n"));
; 140  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	44 89 41 14	 mov	 DWORD PTR [rcx+20], r8d
  00062	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [rcx+24], -1
  00069	c7 41 1c 00 80
	00 00		 mov	 DWORD PTR [rcx+28], 32768 ; 00008000H
  00070	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  00074	4c 89 41 48	 mov	 QWORD PTR [rcx+72], r8
  00078	c7 81 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+7136], 1
  00082	c7 81 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rcx+7140], -1

; 141  : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 159  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b da		 mov	 ebx, edx
  00016	48 8b e9	 mov	 rbp, rcx

; 160  :     int wrap;
; 161  :     struct inflate_state FAR *state;
; 162  : 
; 163  :     /* get the state */
; 164  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00019	e8 00 00 00 00	 call	 inflateStateCheck
  0001e	85 c0		 test	 eax, eax
  00020	75 57		 jne	 SHORT $LN7@inflateRes

; 165  :     state = (struct inflate_state FAR *)strm->state;

  00022	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 166  : 
; 167  :     /* extract wrap request from windowBits parameter */
; 168  :     if (windowBits < 0) {

  00026	85 d2		 test	 edx, edx
  00028	79 06		 jns	 SHORT $LN3@inflateRes

; 169  :         wrap = 0;

  0002a	33 f6		 xor	 esi, esi

; 170  :         windowBits = -windowBits;

  0002c	f7 db		 neg	 ebx

; 171  :     }

  0002e	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 172  :     else {
; 173  :         wrap = (windowBits >> 4) + 5;

  00030	8b f3		 mov	 esi, ebx
  00032	c1 ee 04	 shr	 esi, 4
  00035	83 c6 05	 add	 esi, 5

; 174  : #ifdef GUNZIP
; 175  :         if (windowBits < 48)

  00038	83 fb 30	 cmp	 ebx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN5@inflateRes

; 176  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN5@inflateRes:

; 177  : #endif
; 178  :     }
; 179  : 
; 180  :     /* set number of window bits, free window if different */
; 181  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00040	85 db		 test	 ebx, ebx
  00042	74 08		 je	 SHORT $LN6@inflateRes
  00044	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  00047	83 f8 07	 cmp	 eax, 7
  0004a	77 2d		 ja	 SHORT $LN7@inflateRes
$LN6@inflateRes:

; 183  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0004c	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  00050	48 85 d2	 test	 rdx, rdx
  00053	74 14		 je	 SHORT $LN8@inflateRes
  00055	39 5f 30	 cmp	 DWORD PTR [rdi+48], ebx
  00058	74 0f		 je	 SHORT $LN8@inflateRes

; 184  :         ZFREE(strm, state->window);

  0005a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0005e	ff 55 38	 call	 QWORD PTR [rbp+56]

; 185  :         state->window = Z_NULL;

  00061	48 c7 47 40 00
	00 00 00	 mov	 QWORD PTR [rdi+64], 0
$LN8@inflateRes:

; 186  :     }
; 187  : 
; 188  :     /* update state and reset the rest of it */
; 189  :     state->wrap = wrap;
; 190  :     state->wbits = (unsigned)windowBits;
; 191  :     return inflateReset(strm);

  00069	48 8b cd	 mov	 rcx, rbp
  0006c	89 77 10	 mov	 DWORD PTR [rdi+16], esi
  0006f	89 5f 30	 mov	 DWORD PTR [rdi+48], ebx
  00072	e8 00 00 00 00	 call	 inflateReset
  00077	eb 05		 jmp	 SHORT $LN1@inflateRes
$LN7@inflateRes:

; 182  :         return Z_STREAM_ERROR;

  00079	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateRes:

; 192  : }

  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00088	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 243  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
inflatePrime PROC					; COMDAT

; 250  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d

; 251  :     struct inflate_state FAR *state;
; 252  : 
; 253  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	75 46		 jne	 SHORT $LN5@inflatePri

; 254  :     state = (struct inflate_state FAR *)strm->state;

  00010	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]

; 255  :     if (bits < 0) {

  00014	85 d2		 test	 edx, edx
  00016	79 09		 jns	 SHORT $LN3@inflatePri

; 256  :         state->hold = 0;

  00018	49 89 41 48	 mov	 QWORD PTR [r9+72], rax

; 265  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
$LN3@inflatePri:

; 257  :         state->bits = 0;
; 258  :         return Z_OK;
; 259  :     }
; 260  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00021	83 fa 10	 cmp	 edx, 16
  00024	7f 30		 jg	 SHORT $LN5@inflatePri
  00026	45 8b 41 4c	 mov	 r8d, DWORD PTR [r9+76]
  0002a	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  0002e	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  00032	77 22		 ja	 SHORT $LN5@inflatePri

; 261  :     value &= (1L << bits) - 1;

  00034	8b ca		 mov	 ecx, edx

; 262  :     state->hold += (unsigned)value << state->bits;
; 263  :     state->bits += (uInt)bits;

  00036	45 89 51 4c	 mov	 DWORD PTR [r9+76], r10d
  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	d3 e0		 shl	 eax, cl
  00041	41 8b c8	 mov	 ecx, r8d
  00044	ff c8		 dec	 eax
  00046	41 23 c3	 and	 eax, r11d
  00049	d3 e0		 shl	 eax, cl
  0004b	41 01 41 48	 add	 DWORD PTR [r9+72], eax

; 264  :     return Z_OK;

  0004f	33 c0		 xor	 eax, eax

; 265  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN5@inflatePri:

; 257  :         state->bits = 0;
; 258  :         return Z_OK;
; 259  :     }
; 260  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00056	b8 fe ff ff ff	 mov	 eax, -2

; 265  : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 280  : #ifdef BUILDFIXED
; 281  :     static int virgin = 1;
; 282  :     static code *lenfix, *distfix;
; 283  :     static code fixed[544];
; 284  : 
; 285  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 286  :     if (virgin) {
; 287  :         unsigned sym, bits;
; 288  :         static code *next;
; 289  : 
; 290  :         /* literal/length table */
; 291  :         sym = 0;
; 292  :         while (sym < 144) state->lens[sym++] = 8;
; 293  :         while (sym < 256) state->lens[sym++] = 9;
; 294  :         while (sym < 280) state->lens[sym++] = 7;
; 295  :         while (sym < 288) state->lens[sym++] = 8;
; 296  :         next = fixed;
; 297  :         lenfix = next;
; 298  :         bits = 9;
; 299  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 300  : 
; 301  :         /* distance table */
; 302  :         sym = 0;
; 303  :         while (sym < 32) state->lens[sym++] = 5;
; 304  :         distfix = next;
; 305  :         bits = 5;
; 306  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 307  : 
; 308  :         /* do this just once */
; 309  :         virgin = 0;
; 310  :     }
; 311  : #else /* !BUILDFIXED */
; 312  : #   include "inffixed.h"
; 313  : #endif /* BUILDFIXED */
; 314  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 315  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 316  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 317  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 318  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
end$ = 56
copy$ = 64
updatewindow PROC					; COMDAT

; 399  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 400  :     struct inflate_state FAR *state;
; 401  :     unsigned dist;
; 402  : 
; 403  :     state = (struct inflate_state FAR *)strm->state;

  0000f	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	41 8b e8	 mov	 ebp, r8d
  00019	4c 8b d1	 mov	 r10, rcx

; 404  : 
; 405  :     /* if it hasn't been done already, allocate space for the window */
; 406  :     if (state->window == Z_NULL) {

  0001c	4c 8b 4b 40	 mov	 r9, QWORD PTR [rbx+64]
  00020	4d 85 c9	 test	 r9, r9
  00023	75 36		 jne	 SHORT $LN15@updatewind

; 407  :         state->window = (unsigned char FAR *)

  00025	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00028	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0002c	ba 01 00 00 00	 mov	 edx, 1
  00031	d3 e2		 shl	 edx, cl
  00033	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  00037	41 ff 52 30	 call	 QWORD PTR [r10+48]
  0003b	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
  0003f	4c 8b c8	 mov	 r9, rax

; 408  :                         ZALLOC(strm, 1U << state->wbits,
; 409  :                                sizeof(unsigned char));
; 410  :         if (state->window == Z_NULL) return 1;

  00042	48 85 c0	 test	 rax, rax
  00045	75 14		 jne	 SHORT $LN15@updatewind
  00047	41 8d 41 01	 lea	 eax, QWORD PTR [r9+1]

; 443  : }

  0004b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00050	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5e		 pop	 rsi
  0005a	c3		 ret	 0
$LN15@updatewind:
  0005b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 411  :     }
; 412  : 
; 413  :     /* if window not in use yet, initialize */
; 414  :     if (state->wsize == 0) {

  00060	8b 7b 34	 mov	 edi, DWORD PTR [rbx+52]
  00063	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00068	45 33 f6	 xor	 r14d, r14d
  0006b	85 ff		 test	 edi, edi
  0006d	75 11		 jne	 SHORT $LN14@updatewind

; 415  :         state->wsize = 1U << state->wbits;

  0006f	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00072	bf 01 00 00 00	 mov	 edi, 1
  00077	d3 e7		 shl	 edi, cl
  00079	89 7b 34	 mov	 DWORD PTR [rbx+52], edi

; 416  :         state->wnext = 0;
; 417  :         state->whave = 0;

  0007c	4c 89 73 38	 mov	 QWORD PTR [rbx+56], r14
$LN14@updatewind:

; 418  :     }
; 419  : 
; 420  :     /* copy state->wsize or less output bytes into the circular window */
; 421  :     if (copy >= state->wsize) {

  00080	3b ef		 cmp	 ebp, edi
  00082	72 1a		 jb	 SHORT $LN5@updatewind

; 422  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00084	44 8b c7	 mov	 r8d, edi
  00087	49 8b c9	 mov	 rcx, r9
  0008a	49 2b f0	 sub	 rsi, r8
  0008d	48 8b d6	 mov	 rdx, rsi
  00090	e8 00 00 00 00	 call	 memcpy

; 423  :         state->wnext = 0;
; 424  :         state->whave = state->wsize;

  00095	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00098	44 89 73 3c	 mov	 DWORD PTR [rbx+60], r14d

; 425  :     }

  0009c	eb 53		 jmp	 SHORT $LN16@updatewind
$LN5@updatewind:

; 426  :     else {
; 427  :         dist = state->wsize - state->wnext;

  0009e	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]

; 428  :         if (dist > copy) dist = copy;
; 429  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  000a1	48 8b d6	 mov	 rdx, rsi
  000a4	2b f9		 sub	 edi, ecx
  000a6	3b fd		 cmp	 edi, ebp
  000a8	0f 47 fd	 cmova	 edi, ebp
  000ab	48 2b d5	 sub	 rdx, rbp
  000ae	44 8b c7	 mov	 r8d, edi
  000b1	49 03 c9	 add	 rcx, r9
  000b4	e8 00 00 00 00	 call	 memcpy

; 430  :         copy -= dist;

  000b9	2b ef		 sub	 ebp, edi

; 431  :         if (copy) {

  000bb	74 1a		 je	 SHORT $LN8@updatewind

; 432  :             zmemcpy(state->window, end - copy, copy);

  000bd	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c1	44 8b c5	 mov	 r8d, ebp
  000c4	49 2b f0	 sub	 rsi, r8
  000c7	48 8b d6	 mov	 rdx, rsi
  000ca	e8 00 00 00 00	 call	 memcpy

; 433  :             state->wnext = copy;
; 434  :             state->whave = state->wsize;

  000cf	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000d2	89 6b 3c	 mov	 DWORD PTR [rbx+60], ebp

; 435  :         }

  000d5	eb 1a		 jmp	 SHORT $LN16@updatewind
$LN8@updatewind:

; 436  :         else {
; 437  :             state->wnext += dist;

  000d7	01 7b 3c	 add	 DWORD PTR [rbx+60], edi

; 438  :             if (state->wnext == state->wsize) state->wnext = 0;

  000da	8b 43 3c	 mov	 eax, DWORD PTR [rbx+60]
  000dd	3b 43 34	 cmp	 eax, DWORD PTR [rbx+52]
  000e0	41 0f 44 c6	 cmove	 eax, r14d
  000e4	89 43 3c	 mov	 DWORD PTR [rbx+60], eax

; 439  :             if (state->whave < state->wsize) state->whave += dist;

  000e7	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  000ea	3b 43 34	 cmp	 eax, DWORD PTR [rbx+52]
  000ed	73 05		 jae	 SHORT $LN11@updatewind
  000ef	03 c7		 add	 eax, edi
$LN16@updatewind:

; 440  :         }
; 441  :     }
; 442  :     return 0;

  000f1	89 43 38	 mov	 DWORD PTR [rbx+56], eax
$LN11@updatewind:
  000f4	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  000f9	33 c0		 xor	 eax, eax
  000fb	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 443  : }

  00100	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00105	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5e		 pop	 rsi
  0010f	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1313 : {

$LN7:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b f2	 mov	 rsi, rdx

; 1314 :     struct inflate_state FAR *state;
; 1315 : 
; 1316 :     /* check state */
; 1317 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	74 10		 je	 SHORT $LN2@inflateGet
  00019	b8 fe ff ff ff	 mov	 eax, -2

; 1330 : }

  0001e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
$LN2@inflateGet:
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1318 :     state = (struct inflate_state FAR *)strm->state;

  0002e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1319 : 
; 1320 :     /* copy dictionary */
; 1321 :     if (state->whave && dictionary != Z_NULL) {

  00032	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00035	85 c0		 test	 eax, eax
  00037	74 2f		 je	 SHORT $LN3@inflateGet
  00039	48 85 f6	 test	 rsi, rsi
  0003c	74 2a		 je	 SHORT $LN3@inflateGet

; 1322 :         zmemcpy(dictionary, state->window + state->wnext,

  0003e	8b 53 3c	 mov	 edx, DWORD PTR [rbx+60]
  00041	48 8b ce	 mov	 rcx, rsi
  00044	2b c2		 sub	 eax, edx
  00046	48 03 53 40	 add	 rdx, QWORD PTR [rbx+64]
  0004a	44 8b c0	 mov	 r8d, eax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1323 :                 state->whave - state->wnext);
; 1324 :         zmemcpy(dictionary + state->whave - state->wnext,

  00052	44 8b 43 3c	 mov	 r8d, DWORD PTR [rbx+60]
  00056	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00059	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0005d	49 2b c8	 sub	 rcx, r8
  00060	48 03 ce	 add	 rcx, rsi
  00063	e8 00 00 00 00	 call	 memcpy
$LN3@inflateGet:

; 1325 :                 state->window, state->wnext);
; 1326 :     }
; 1327 :     if (dictLength != Z_NULL)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 05		 je	 SHORT $LN4@inflateGet

; 1328 :         *dictLength = state->whave;

  0006d	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00070	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@inflateGet:

; 1329 :     return Z_OK;

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	33 c0		 xor	 eax, eax

; 1330 : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1333 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f0	 mov	 esi, r8d
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 1334 :     struct inflate_state FAR *state;
; 1335 :     unsigned long dictid;
; 1336 :     int ret;
; 1337 : 
; 1338 :     /* check state */
; 1339 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0001d	e8 00 00 00 00	 call	 inflateStateCheck
  00022	85 c0		 test	 eax, eax
  00024	75 6c		 jne	 SHORT $LN10@inflateSet

; 1340 :     state = (struct inflate_state FAR *)strm->state;

  00026	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1341 :     if (state->wrap != 0 && state->mode != DICT)

  0002a	39 43 10	 cmp	 DWORD PTR [rbx+16], eax
  0002d	74 09		 je	 SHORT $LN9@inflateSet
  0002f	81 7b 08 3e 3f
	00 00		 cmp	 DWORD PTR [rbx+8], 16190 ; 00003f3eH
  00036	75 5a		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1343 : 
; 1344 :     /* check for correct dictionary identifier */
; 1345 :     if (state->mode == DICT) {

  00038	81 7b 08 3e 3f
	00 00		 cmp	 DWORD PTR [rbx+8], 16190 ; 00003f3eH
  0003f	75 25		 jne	 SHORT $LN5@inflateSet

; 1346 :         dictid = adler32(0L, Z_NULL, 0);

  00041	45 33 c0	 xor	 r8d, r8d
  00044	33 d2		 xor	 edx, edx
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 adler32

; 1347 :         dictid = adler32(dictid, dictionary, dictLength);

  0004d	44 8b c6	 mov	 r8d, esi
  00050	48 8b d5	 mov	 rdx, rbp
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 adler32

; 1348 :         if (dictid != state->check)

  0005a	3b 43 20	 cmp	 eax, DWORD PTR [rbx+32]
  0005d	74 07		 je	 SHORT $LN5@inflateSet

; 1349 :             return Z_DATA_ERROR;

  0005f	b8 fd ff ff ff	 mov	 eax, -3
  00064	eb 31		 jmp	 SHORT $LN1@inflateSet
$LN5@inflateSet:

; 1350 :     }
; 1351 : 
; 1352 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1353 :        existing dictionary if appropriate */
; 1354 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00066	48 8d 14 2e	 lea	 rdx, QWORD PTR [rsi+rbp]
  0006a	44 8b c6	 mov	 r8d, esi
  0006d	48 8b cf	 mov	 rcx, rdi
  00070	e8 00 00 00 00	 call	 updatewindow

; 1355 :     if (ret) {

  00075	85 c0		 test	 eax, eax
  00077	74 0e		 je	 SHORT $LN6@inflateSet

; 1356 :         state->mode = MEM;

  00079	c7 43 08 52 3f
	00 00		 mov	 DWORD PTR [rbx+8], 16210 ; 00003f52H

; 1357 :         return Z_MEM_ERROR;

  00080	b8 fc ff ff ff	 mov	 eax, -4
  00085	eb 10		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1358 :     }
; 1359 :     state->havedict = 1;

  00087	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [rbx+20], 1

; 1360 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1361 :     return Z_OK;

  0008e	33 c0		 xor	 eax, eax
  00090	eb 05		 jmp	 SHORT $LN1@inflateSet
$LN10@inflateSet:

; 1342 :         return Z_STREAM_ERROR;

  00092	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateSet:

; 1362 : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
inflateGetHeader PROC					; COMDAT

; 1367 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1368 :     struct inflate_state FAR *state;
; 1369 : 
; 1370 :     /* check state */
; 1371 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	75 1c		 jne	 SHORT $LN5@inflateGet

; 1372 :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1373 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 40 10 02	 test	 BYTE PTR [rax+16], 2
  00015	74 12		 je	 SHORT $LN5@inflateGet

; 1374 : 
; 1375 :     /* save header structure */
; 1376 :     state->head = head;

  00017	48 89 50 28	 mov	 QWORD PTR [rax+40], rdx

; 1377 :     head->done = 0;
; 1378 :     return Z_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1379 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN5@inflateGet:

; 1373 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2

; 1379 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1393 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1394 :     unsigned got;
; 1395 :     unsigned next;
; 1396 : 
; 1397 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1398 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d0	 mov	 r10d, r8d
  0000c	4c 8b d9	 mov	 r11, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1399 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 43		 je	 SHORT $LN13@syncsearch
$LL2@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 32		 jae	 SHORT $LN14@syncsearch

; 1400 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1401 :             ++got;

  00030	ff c0		 inc	 eax
  00032	eb 0f		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1402 :         else if (buf[next])
; 1403 :             got = 0;
; 1404 :         else
; 1405 :             got = 4 - got;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	2b c8		 sub	 ecx, eax
  0003b	45 84 c0	 test	 r8b, r8b
  0003e	8b c1		 mov	 eax, ecx
  00040	0f 45 c3	 cmovne	 eax, ebx
$LN7@syncsearch:

; 1406 :         ++next;

  00043	41 ff c1	 inc	 r9d
  00046	48 ff c2	 inc	 rdx
  00049	45 3b ca	 cmp	 r9d, r10d
  0004c	72 c9		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1407 :     }
; 1408 :     *have = got;
; 1409 :     return next;
; 1410 : }

  0004e	41 89 03	 mov	 DWORD PTR [r11], eax
  00051	41 8b c1	 mov	 eax, r9d
  00054	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00059	c3		 ret	 0
$LN13@syncsearch:
  0005a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005f	89 01		 mov	 DWORD PTR [rcx], eax
  00061	41 8b c1	 mov	 eax, r9d
  00064	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
strm$ = 64
buf$ = 72
inflateSync PROC					; COMDAT

; 1413 : {

$LN22:
  00000	41 56		 push	 r14
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	4c 8b f1	 mov	 r14, rcx

; 1414 :     unsigned len;               /* number of bytes to look at or looked at */
; 1415 :     int flags;                  /* temporary to save header status */
; 1416 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1417 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1418 :     struct inflate_state FAR *state;
; 1419 : 
; 1420 :     /* check parameters */
; 1421 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1459 : }

  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	41 5e		 pop	 r14
  0001d	c3		 ret	 0
$LN4@inflateSyn:

; 1422 :     state = (struct inflate_state FAR *)strm->state;
; 1423 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001e	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  00022	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00027	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]
  0002b	45 85 c0	 test	 r8d, r8d
  0002e	75 16		 jne	 SHORT $LN17@inflateSyn
  00030	83 7e 4c 08	 cmp	 DWORD PTR [rsi+76], 8
  00034	73 10		 jae	 SHORT $LN17@inflateSyn
  00036	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0003b	41 8d 40 fb	 lea	 eax, QWORD PTR [r8-5]

; 1459 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	41 5e		 pop	 r14
  00045	c3		 ret	 0
$LN17@inflateSyn:
  00046	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0004b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 1424 : 
; 1425 :     /* if first time, start search in bit buffer */
; 1426 :     if (state->mode != SYNC) {

  00050	33 ff		 xor	 edi, edi
  00052	81 7e 08 53 3f
	00 00		 cmp	 DWORD PTR [rsi+8], 16211 ; 00003f53H
  00059	74 67		 je	 SHORT $LN15@inflateSyn

; 1427 :         state->mode = SYNC;
; 1428 :         state->hold <<= state->bits & 7;

  0005b	8b 56 4c	 mov	 edx, DWORD PTR [rsi+76]

; 1429 :         state->bits -= state->bits & 7;
; 1430 :         len = 0;

  0005e	44 8b cf	 mov	 r9d, edi
  00061	44 8b 46 48	 mov	 r8d, DWORD PTR [rsi+72]
  00065	8b ca		 mov	 ecx, edx
  00067	83 e1 07	 and	 ecx, 7
  0006a	c7 46 08 53 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16211 ; 00003f53H
  00071	41 d3 e0	 shl	 r8d, cl
  00074	2b d1		 sub	 edx, ecx
  00076	44 89 46 48	 mov	 DWORD PTR [rsi+72], r8d
  0007a	89 56 4c	 mov	 DWORD PTR [rsi+76], edx

; 1431 :         while (state->bits >= 8) {

  0007d	83 fa 08	 cmp	 edx, 8
  00080	72 21		 jb	 SHORT $LN3@inflateSyn
$LL2@inflateSyn:

; 1432 :             buf[len++] = (unsigned char)(state->hold);

  00082	0f b6 46 48	 movzx	 eax, BYTE PTR [rsi+72]

; 1433 :             state->hold >>= 8;
; 1434 :             state->bits -= 8;

  00086	83 c2 f8	 add	 edx, -8			; fffffff8H
  00089	41 8b c9	 mov	 ecx, r9d
  0008c	41 ff c1	 inc	 r9d
  0008f	41 c1 e8 08	 shr	 r8d, 8
  00093	44 89 46 48	 mov	 DWORD PTR [rsi+72], r8d
  00097	88 44 0c 48	 mov	 BYTE PTR buf$[rsp+rcx], al
  0009b	83 fa 08	 cmp	 edx, 8
  0009e	73 e2		 jae	 SHORT $LL2@inflateSyn
  000a0	89 56 4c	 mov	 DWORD PTR [rsi+76], edx
$LN3@inflateSyn:

; 1435 :         }
; 1436 :         state->have = 0;

  000a3	48 8d 9e 84 00
	00 00		 lea	 rbx, QWORD PTR [rsi+132]

; 1437 :         syncsearch(&(state->have), buf, len);

  000aa	45 8b c1	 mov	 r8d, r9d
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	89 3b		 mov	 DWORD PTR [rbx], edi
  000b2	48 8d 54 24 48	 lea	 rdx, QWORD PTR buf$[rsp]
  000b7	e8 00 00 00 00	 call	 syncsearch
  000bc	45 8b 46 08	 mov	 r8d, DWORD PTR [r14+8]
  000c0	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN15@inflateSyn:
  000c2	48 8d 9e 84 00
	00 00		 lea	 rbx, QWORD PTR [rsi+132]
$LN6@inflateSyn:

; 1438 :     }
; 1439 : 
; 1440 :     /* search available input */
; 1441 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000c9	49 8b 16	 mov	 rdx, QWORD PTR [r14]
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	e8 00 00 00 00	 call	 syncsearch

; 1442 :     strm->avail_in -= len;

  000d4	41 29 46 08	 sub	 DWORD PTR [r14+8], eax

; 1443 :     strm->next_in += len;
; 1444 :     strm->total_in += len;

  000d8	41 01 46 0c	 add	 DWORD PTR [r14+12], eax
  000dc	8b c8		 mov	 ecx, eax
  000de	49 01 0e	 add	 QWORD PTR [r14], rcx

; 1445 : 
; 1446 :     /* return no joy or set up to restart inflate() on a new block */
; 1447 :     if (state->have != 4) return Z_DATA_ERROR;

  000e1	83 3b 04	 cmp	 DWORD PTR [rbx], 4
  000e4	74 07		 je	 SHORT $LN7@inflateSyn
  000e6	b8 fd ff ff ff	 mov	 eax, -3
  000eb	eb 3f		 jmp	 SHORT $LN20@inflateSyn
$LN7@inflateSyn:
  000ed	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 1448 :     if (state->flags == -1)

  000f2	8b 6e 18	 mov	 ebp, DWORD PTR [rsi+24]
  000f5	83 fd ff	 cmp	 ebp, -1
  000f8	75 05		 jne	 SHORT $LN8@inflateSyn

; 1449 :         state->wrap = 0;    /* if no header yet, treat as raw */

  000fa	89 7e 10	 mov	 DWORD PTR [rsi+16], edi
  000fd	eb 04		 jmp	 SHORT $LN9@inflateSyn
$LN8@inflateSyn:

; 1450 :     else
; 1451 :         state->wrap &= ~4;  /* no point in computing a check value now */

  000ff	83 66 10 fb	 and	 DWORD PTR [rsi+16], -5
$LN9@inflateSyn:

; 1452 :     flags = state->flags;
; 1453 :     in = strm->total_in;  out = strm->total_out;

  00103	41 8b 7e 0c	 mov	 edi, DWORD PTR [r14+12]

; 1454 :     inflateReset(strm);

  00107	49 8b ce	 mov	 rcx, r14
  0010a	41 8b 5e 1c	 mov	 ebx, DWORD PTR [r14+28]
  0010e	e8 00 00 00 00	 call	 inflateReset

; 1455 :     strm->total_in = in;  strm->total_out = out;

  00113	41 89 7e 0c	 mov	 DWORD PTR [r14+12], edi

; 1456 :     state->flags = flags;
; 1457 :     state->mode = TYPE;
; 1458 :     return Z_OK;

  00117	33 c0		 xor	 eax, eax
  00119	41 89 5e 1c	 mov	 DWORD PTR [r14+28], ebx
  0011d	89 6e 18	 mov	 DWORD PTR [rsi+24], ebp
  00120	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00125	c7 46 08 3f 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16191 ; 00003f3fH
$LN20@inflateSyn:
  0012c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00131	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00136	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]

; 1459 : }

  0013b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013f	41 5e		 pop	 r14
  00141	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 48
inflateSyncPoint PROC					; COMDAT

; 1470 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1471 :     struct inflate_state FAR *state;
; 1472 : 
; 1473 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateSyn
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1476 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateSyn:

; 1474 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1475 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00022	75 10		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00028	75 0a		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1476 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@inflateSyn:

; 1475 :     return state->mode == STORED && state->bits == 0;

  00034	33 c0		 xor	 eax, eax

; 1476 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1481 : {

$LN17:
  00000	40 57		 push	 rdi
  00002	41 56		 push	 r14
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	4c 8b f1	 mov	 r14, rcx
  0000b	48 8b fa	 mov	 rdi, rdx

; 1482 :     struct inflate_state FAR *state;
; 1483 :     struct inflate_state FAR *copy;
; 1484 :     unsigned char FAR *window;
; 1485 :     unsigned wsize;
; 1486 : 
; 1487 :     /* check input */
; 1488 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0000e	48 8b ca	 mov	 rcx, rdx
  00011	e8 00 00 00 00	 call	 inflateStateCheck
  00016	85 c0		 test	 eax, eax
  00018	0f 85 7c 01 00
	00		 jne	 $LN3@inflateCop
  0001e	4d 85 f6	 test	 r14, r14
  00021	0f 84 73 01 00
	00		 je	 $LN3@inflateCop

; 1490 :     state = (struct inflate_state FAR *)source->state;
; 1491 : 
; 1492 :     /* allocate space */
; 1493 :     copy = (struct inflate_state FAR *)

  00027	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002b	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00031	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00036	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0003b	bd 01 00 00 00	 mov	 ebp, 1
  00040	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00045	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  00049	8b d5		 mov	 edx, ebp
  0004b	ff 57 30	 call	 QWORD PTR [rdi+48]
  0004e	48 8b d8	 mov	 rbx, rax

; 1494 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1495 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00051	48 85 c0	 test	 rax, rax
  00054	75 05		 jne	 SHORT $LN4@inflateCop
  00056	8d 45 fb	 lea	 eax, QWORD PTR [rbp-5]
  00059	eb 3a		 jmp	 SHORT $LN14@inflateCop
$LN4@inflateCop:
  0005b	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 1496 :     window = Z_NULL;

  00060	45 33 ff	 xor	 r15d, r15d

; 1497 :     if (state->window != Z_NULL) {

  00063	4c 39 7e 40	 cmp	 QWORD PTR [rsi+64], r15
  00067	74 43		 je	 SHORT $LN11@inflateCop

; 1498 :         window = (unsigned char FAR *)

  00069	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]
  0006c	8b d5		 mov	 edx, ebp
  0006e	d3 e2		 shl	 edx, cl
  00070	44 8b c5	 mov	 r8d, ebp
  00073	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00077	ff 57 30	 call	 QWORD PTR [rdi+48]
  0007a	4c 8b f8	 mov	 r15, rax

; 1499 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1500 :         if (window == Z_NULL) {

  0007d	48 85 c0	 test	 rax, rax
  00080	75 2a		 jne	 SHORT $LN11@inflateCop

; 1501 :             ZFREE(source, copy);

  00082	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00086	48 8b d3	 mov	 rdx, rbx
  00089	ff 57 38	 call	 QWORD PTR [rdi+56]

; 1502 :             return Z_MEM_ERROR;

  0008c	41 8d 47 fc	 lea	 eax, QWORD PTR [r15-4]
$LN15@inflateCop:
  00090	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
$LN14@inflateCop:
  00095	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1523 : }

  000a4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a8	41 5e		 pop	 r14
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN11@inflateCop:

; 1503 :         }
; 1504 :     }
; 1505 : 
; 1506 :     /* copy state */
; 1507 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000ac	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 1508 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000af	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000b5	48 8b d6	 mov	 rdx, rsi
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	41 0f 11 06	 movups	 XMMWORD PTR [r14], xmm0
  000bf	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  000c3	41 0f 11 4e 10	 movups	 XMMWORD PTR [r14+16], xmm1
  000c8	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [rdi+32]
  000cc	41 0f 11 46 20	 movups	 XMMWORD PTR [r14+32], xmm0
  000d1	0f 10 4f 30	 movups	 xmm1, XMMWORD PTR [rdi+48]
  000d5	41 0f 11 4e 30	 movups	 XMMWORD PTR [r14+48], xmm1
  000da	0f 10 47 40	 movups	 xmm0, XMMWORD PTR [rdi+64]
  000de	41 0f 11 46 40	 movups	 XMMWORD PTR [r14+64], xmm0
  000e3	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [rdi+80]
  000e8	f2 41 0f 11 4e
	50		 movsd	 QWORD PTR [r14+80], xmm1
  000ee	e8 00 00 00 00	 call	 memcpy

; 1509 :     copy->strm = dest;

  000f3	4c 89 33	 mov	 QWORD PTR [rbx], r14

; 1510 :     if (state->lencode >= state->codes &&

  000f6	48 8d 86 50 05
	00 00		 lea	 rax, QWORD PTR [rsi+1360]
  000fd	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00101	48 3b c8	 cmp	 rcx, rax
  00104	72 47		 jb	 SHORT $LN7@inflateCop
  00106	48 8d 86 dc 1b
	00 00		 lea	 rax, QWORD PTR [rsi+7132]
  0010d	48 3b c8	 cmp	 rcx, rax
  00110	77 3b		 ja	 SHORT $LN7@inflateCop

; 1511 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1512 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00112	48 2b ce	 sub	 rcx, rsi
  00115	48 8d 81 b0 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1360]
  0011c	48 c1 f8 02	 sar	 rax, 2
  00120	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00126	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0012a	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1513 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  0012e	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  00132	48 2b c6	 sub	 rax, rsi
  00135	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0013b	48 c1 f8 02	 sar	 rax, 2
  0013f	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00145	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00149	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LN7@inflateCop:

; 1514 :     }
; 1515 :     copy->next = copy->codes + (state->next - state->codes);

  0014d	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  00154	48 2b c6	 sub	 rax, rsi
  00157	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0015d	48 c1 f8 02	 sar	 rax, 2
  00161	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00167	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0016b	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1516 :     if (window != Z_NULL) {

  00172	4d 85 ff	 test	 r15, r15
  00175	74 14		 je	 SHORT $LN8@inflateCop

; 1517 :         wsize = 1U << state->wbits;

  00177	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]

; 1518 :         zmemcpy(window, state->window, wsize);

  0017a	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  0017e	d3 e5		 shl	 ebp, cl
  00180	49 8b cf	 mov	 rcx, r15
  00183	44 8b c5	 mov	 r8d, ebp
  00186	e8 00 00 00 00	 call	 memcpy
$LN8@inflateCop:

; 1519 :     }
; 1520 :     copy->window = window;

  0018b	4c 89 7b 40	 mov	 QWORD PTR [rbx+64], r15

; 1521 :     dest->state = (struct internal_state FAR *)copy;
; 1522 :     return Z_OK;

  0018f	33 c0		 xor	 eax, eax
  00191	49 89 5e 28	 mov	 QWORD PTR [r14+40], rbx
  00195	e9 f6 fe ff ff	 jmp	 $LN15@inflateCop
$LN3@inflateCop:

; 1489 :         return Z_STREAM_ERROR;

  0019a	b8 fe ff ff ff	 mov	 eax, -2

; 1523 : }

  0019f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001a3	41 5e		 pop	 r14
  001a5	5f		 pop	 rdi
  001a6	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 48
subvert$ = 56
inflateUndermine PROC					; COMDAT

; 1526 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1527 :     struct inflate_state FAR *state;
; 1528 : 
; 1529 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateUnd
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1538 : #endif
; 1539 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateUnd:

; 1530 :     state = (struct inflate_state FAR *)strm->state;
; 1531 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1532 :     state->sane = !subvert;
; 1533 :     return Z_OK;
; 1534 : #else
; 1535 :     (void)subvert;
; 1536 :     state->sane = 1;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0001b	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1537 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3

; 1538 : #endif
; 1539 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
strm$ = 48
check$ = 56
inflateValidate PROC					; COMDAT

; 1542 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1543 :     struct inflate_state FAR *state;
; 1544 : 
; 1545 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateVal
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1552 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateVal:

; 1546 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1547 :     if (check && state->wrap)

  0001b	85 d2		 test	 edx, edx
  0001d	74 14		 je	 SHORT $LN7@inflateVal
  0001f	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00022	85 c9		 test	 ecx, ecx
  00024	74 0d		 je	 SHORT $LN7@inflateVal

; 1548 :         state->wrap |= 4;

  00026	83 c9 04	 or	 ecx, 4
  00029	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1551 :     return Z_OK;

  0002c	33 c0		 xor	 eax, eax

; 1552 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN7@inflateVal:

; 1549 :     else
; 1550 :         state->wrap &= ~4;

  00033	83 60 10 fb	 and	 DWORD PTR [rax+16], -5

; 1551 :     return Z_OK;

  00037	33 c0		 xor	 eax, eax

; 1552 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 48
inflateMark PROC					; COMDAT

; 1555 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1556 :     struct inflate_state FAR *state;
; 1557 : 
; 1558 :     if (inflateStateCheck(strm))

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateMar

; 1559 :         return -(1L << 16);

  0000d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1562 :         (state->mode == COPY ? state->length :
; 1563 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1564 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateMar:

; 1560 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1561 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 13		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00029	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  0002f	c1 e0 10	 shl	 eax, 16
  00032	03 c1		 add	 eax, ecx

; 1562 :         (state->mode == COPY ? state->length :
; 1563 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1564 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN6@inflateMar:

; 1561 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00039	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003f	75 19		 jne	 SHORT $LN4@inflateMar
  00041	8b 88 e8 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7144]
  00047	2b 48 50	 sub	 ecx, DWORD PTR [rax+80]
  0004a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00050	c1 e0 10	 shl	 eax, 16
  00053	03 c1		 add	 eax, ecx

; 1562 :         (state->mode == COPY ? state->length :
; 1563 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1564 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN4@inflateMar:

; 1561 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0005a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00060	33 c9		 xor	 ecx, ecx
  00062	c1 e0 10	 shl	 eax, 16
  00065	03 c1		 add	 eax, ecx

; 1562 :         (state->mode == COPY ? state->length :
; 1563 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1564 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\UserFiles\Github\zlib-win64\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
strm$ = 48
inflateCodesUsed PROC					; COMDAT

; 1567 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1568 :     struct inflate_state FAR *state;
; 1569 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateCod
  0000d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1572 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateCod:

; 1570 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 1571 :     return (unsigned long)(state->next - state->codes);

  0001b	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00022	48 2b c1	 sub	 rax, rcx
  00025	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0002b	48 c1 f8 02	 sar	 rax, 2

; 1572 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
